const fs = require("fs");

var totalData = [
  {
    name: "1\nThreeJS基础\n学习时长: 26分48秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">ThreeJS 基础</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>ThreeJS 框架中<code>光源</code>、<code>相机</code>、<code>渲染器</code>、<code>几何体</code>、<code>材质</code>以及<code>场景</code>等对象的相关知识并使用这些对象基于一个<code>基础的程序结构</code>构建出 3D 场景，效果如下：</li>\n</ol>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166851312d8e0764~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>示例地址为 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnewbieyoung.github.io%2FThreejs_rubik%2Flesson%2Fdemo0.html" target="_blank" rel="nofollow noopener noreferrer" title="https://newbieyoung.github.io/Threejs_rubik/lesson/demo0.html" ref="nofollow noopener noreferrer">newbieyoung.github.io/Threejs_rub…</a></p>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Fblob%2Fmaster%2Flesson%2Fdemo0.html" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/blob/master/lesson/demo0.html" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中。</p>\n<ol start="2">\n<li><code>右手坐标系</code>、<code>三角形网格</code>等计算机图形学基础概念的相关知识；</li>\n<li>进一步学习 ThreeJS 框架以及 3D 相关知识的个人建议。</li>\n</ol>\n<p>重要的事只说一遍，<code>本章以及后续所有章节的示例最好都动手实现一次！</code></p>\n<h2 data-id="heading-2">概述</h2>\n<p><code>ThreeJS</code>是由 Ricardo Cabello 在 2010 年 4 月开源于 GitHub 的 3D 框架，基于这个框架我们可以直接使用 JavaScript 语言在网页中构建 3D 场景；</p>\n<p>在开始构建 3D 场景之前，我们需要思考一个问题，你为什么能看到本教程？</p>\n<p>答案很简单，首先你肯定拥有一台电子终端（电脑、手机或者其它），该电子终端渲染出文字并发出光线，接着人眼能接收光线，并在视网膜上成像，最终传送给大脑。</p>\n<p>然后再仔细想一想上述过程中的关键因素是啥？</p>\n<ul>\n<li>文字：<code>被观测物体</code>；</li>\n<li>能发出光线的电子终端：<code>光源</code>；</li>\n<li>能接收光线的眼睛：<code>相机</code>；</li>\n<li>视网膜：<code>渲染器</code>；</li>\n</ul>\n<p>而正是因为 ThreeJS 框架提供了创建这些关键因素的能力所以我们才能使用它在计算机中构建 3D 场景。</p>\n<h2 data-id="heading-3">基础程序结构</h2>\n<p>首先去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmrdoob%2Fthree.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/mrdoob/three.js" ref="nofollow noopener noreferrer">ThreeJS 的 Github 仓库</a> 下载最新代码；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/1668064b94bc88a6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在<code>build</code>目录中有编译好的未压缩版本<code>three.js</code>和压缩版本<code>three.min.js</code>，使用未压缩版本在开发时可以方便调试，使用压缩版本则体积较小。</p>\n<p>按照上边的理解，我们构建 3D 场景只需要创建四个关键因素即可，代码如下：</p>\n<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>ThreeJS基础<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../threejs/three.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./reset.import.css"</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n            <span class="hljs-comment">//页面加载完成</span>\n            <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n                <span class="hljs-title function_">createWorld</span>();\n            }\n\n            <span class="hljs-comment">//模拟现实场景</span>\n            <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorld</span>(<span class="hljs-params"></span>) {\n                <span class="hljs-title function_">initRender</span>();<span class="hljs-comment">//创建渲染器</span>\n                <span class="hljs-title function_">initCamera</span>();<span class="hljs-comment">//创建相机</span>\n                <span class="hljs-title function_">initLight</span>();<span class="hljs-comment">//创建光源</span>\n                <span class="hljs-title function_">initObject</span>();<span class="hljs-comment">//创建物体</span>\n            }\n        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>在页面加载完成之后，通过<code>initRender()</code>创建渲染器、<code>initCamera()</code>创建相机、<code>initLight()</code>创建光源、<code>initObject()</code>创建物体即可。</p>\n<h2 data-id="heading-4">创建渲染器</h2>\n<p><code>视网膜</code>的作用是<code>成像</code>，在 ThreeJS 框架中的<code>渲染器</code>起到相同的作用；</p>\n<p>ThreeJS 框架提供了好几种渲染器对象，分别使用不同的底层技术实现，比如：</p>\n<ul>\n<li><code>WebGLRenderer</code>使用 WebGL 技术；</li>\n<li><code>CanvasRenderer</code>使用 Canvas 2D 技术；</li>\n<li><code>CSS2DRenderer</code>和<code>CSS3DRenderer</code>则是使用 CSS 技术；</li>\n</ul>\n<p>不同渲染器具有不同的特点，简单来说 WebGLRenderer 最强大，CanvasRenderer、CSS2DRenderer 和 CSS3DRenderer 具有较好的兼容性但同时也有居多限制。</p>\n<p>当前主流浏览器对 WebGL 支持情况良好，在大部分场景中我们都不需要考虑 CanvasRenderer、CSS2DRenderer 和 CSS3DRenderer 这些降级方案，因此示例中使用 WebGLRenderer；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> renderer;<span class="hljs-comment">//渲染器</span>\n<span class="hljs-keyword">var</span> width;\n<span class="hljs-keyword">var</span> height;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initRender</span>(<span class="hljs-params"></span>){\n    width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;\n    height = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>({\n        antialias : <span class="hljs-literal">true</span><span class="hljs-comment">//抗锯齿开启</span>\n    });\n    renderer.<span class="hljs-title function_">setSize</span>(width, height);<span class="hljs-comment">//设置渲染器宽度和高度</span>\n    renderer.<span class="hljs-title function_">setClearColor</span>(<span class="hljs-string">\'#000000\'</span>, <span class="hljs-number">1.0</span>);<span class="hljs-comment">//设置背景颜色</span>\n    renderer.<span class="hljs-title function_">setPixelRatio</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>);<span class="hljs-comment">//设置设备像素比</span>\n    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">\'retina\'</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);<span class="hljs-comment">//把渲染器放置到页面中</span>\n}\n</code></pre>\n<p>调用<code>new THREE.WebGLRenderer()</code>即可创建一个 WebGL 渲染器对象，在初始化时可以传入一些参数，比如设置<code>antialias</code>为<code>true</code>即可开启 WebGL 渲染器的抗锯齿功能；</p>\n<p>调用<code>setSize</code>方法可以设置渲染器的宽度和高度，调用<code>setClearColor</code>方法则是设置背景颜色，最后调用<code>setPixelRatio</code>方法设置设备像素比，用来处理手机等设备的高清屏幕；</p>\n<p>最后需要把渲染器放置到页面中，为此需要一个容器，任意可以加入子元素的 DOM 元素均可，示例中用的是<code>id</code>属性为<code>retina</code>的<code>div</code>元素；</p>\n<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"retina"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h2 data-id="heading-5">创建相机</h2>\n<p><code>相机</code>的作用就类似于<code>人眼</code>，决定了观察的视角和位置；</p>\n<p>ThreeJS 框架同样提供了多种相机，比较常用有两种，分别为<code>PerspectiveCamera</code>透视投影相机和<code>OrthographicCamera</code>正交投影相机；</p>\n<p>其中和<code>人眼</code>观察效果一致的是<code>透视投影相机</code>，用其观察物体时能获得<code>近大远小</code>的效果，因此示例中使用<code>PerspectiveCamera</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> camera;\n<span class="hljs-keyword">var</span> origPoint = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//原点</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initCamera</span>(<span class="hljs-params"></span>){\n    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">45</span>, width / height, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>);\n    camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">200</span>, <span class="hljs-number">400</span>, <span class="hljs-number">600</span>);<span class="hljs-comment">//设置相机位置</span>\n    camera.<span class="hljs-property">up</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//设置相机正方向</span>\n    camera.<span class="hljs-title function_">lookAt</span>(origPoint);<span class="hljs-comment">//设置相机视点</span>\n}\n</code></pre>\n<p>调用<code>new THREE.PerspectiveCamera(fov, aspect, near, far)</code>即可创建一个透视投影相机，其参数意义如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5f89cca8dd1f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li><code>fov</code>表示视角；</li>\n<li><code>aspect</code>表示裁切面宽高比；</li>\n<li><code>near</code>表示近平面距离；</li>\n<li><code>far</code>表示远平面距离；</li>\n</ul>\n<p>只有离相机的距离大于<code>near</code>且小于<code>far</code>，另外还得在相机视角内的物体，才能被相机观察到从而被渲染器渲染出来；</p>\n<p>在设置相机<code>位置</code>、<code>正方向</code>以及<code>视点</code>时，需要基于某个<code>三维坐标系</code>；而在 ThreeJS 框架中我们一般使用的坐标系是当你面朝计算机屏幕时，<code>X轴</code>是水平的（正方向为右），<code>Y轴</code>是垂直的（正方向为上），<code>Z轴</code>垂直于屏幕（正方向为外），这个坐标系也被称为<code>右手坐标系</code>。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669786830d4507c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>之所被称为<code>右手坐标系</code>是因为它是通过如图所示的<code>右手手势</code>确定的，即当你伸出右手摆出如图所示手势时，<code>拇指</code>指向<code>X轴的正方向</code>，<code>食指</code>指向<code>Y轴的正方向</code>，<code>中指</code>指向<code>Z轴的正方向</code>，这种确定坐标系方式也被称为<code>右手定则</code>。</p>\n<p>相机的<code>position</code>属性决定其位置，调用<code>set</code>方法设置到<code>点(200, 400, 600)</code>位置；</p>\n<p>相机的<code>up</code>属性表示相机的正方向，设置<code>三维向量(0, 1, 0)</code>也就是<code>Y轴正方向</code>为相机正方向，类似于<code>人在直立观察</code>；如果把相机正方向设置为<code>Y轴负方向</code>则类似于<code>人在倒立观察</code>。</p>\n<p><code>Vector3</code>是 ThreeJS 框架中的一个对象；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Vector3</span>( x : <span class="hljs-title class_">Float</span>, y : <span class="hljs-title class_">Float</span>, z : <span class="hljs-title class_">Float</span> )\n</code></pre>\n<p>它具有三个属性，分别是<code>x</code>、<code>y</code>、<code>z</code>，这个属性既可以表示三维空间中的<code>点</code>也可以表示<code>向量</code>；</p>\n<blockquote>\n<p>这么设计有优点也有缺点，优点在于可以减少整个框架中对象的类别，如果分开设计那么同时会存在<code>Point3</code>对象和<code>Vector3</code>对象，但是这两个对象从结构上看并没有任何区别；缺点在于容易混淆，创建了一个<code>Vector3</code>对象只有在使用的时候才知道其意义，甚至每次使用意义还可能会发生变化。</p>\n</blockquote>\n<p>相机还有很重要的一个属性<code>视点</code>需要设置，也就是人眼的<code>焦点</code>，调用<code>lookAt</code>方法即可，参数为<code>Vector3</code>对象，<code>点(0, 0, 0)</code>表示<code>坐标系原点</code>。</p>\n<blockquote>\n<p>在 ThreeJS 框架的旧版本中可以直接执行<code>lookAt(0,0,0)</code>，但是在新版本中需要把数据先封装为<code>Vector3</code>对象，否则不生效，导致渲染异常。</p>\n</blockquote>\n<h2 data-id="heading-6">创建光源</h2>\n<p>现实生活中能发光的物体多种多样，有太阳、手电筒以及灯泡等；ThreeJS 框架参考了现实中的各种发光物体封装实现了多种光源；</p>\n<ul>\n<li>方向光</li>\n</ul>\n<p>众所周知因为太阳距离地球的距离足够远，其光线可以近似看作平行光，对应 ThreeJS 框架中的<code>DirectionalLight</code>方向光；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/1668245bc6f1b06b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>从模拟太阳光照射正方体的例子中可以看到对于任意平行的平面，方向光照射的亮度都是相同的。</p>\n<ul>\n<li>聚光灯</li>\n</ul>\n<p>手电筒能够朝着一个方向投射类似圆锥形的光线，对应 ThreeJS 框架中的<code>SpotLight</code>聚光灯。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/16682550b9dbe9e2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>点光源</li>\n</ul>\n<p><code>PointLight</code>点光源则类似于灯泡，其发出的光线照到物体表面的亮度是线性递减的，因此离点光源距离越远的物体会显得越暗。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/16682584297b0533~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>环境光</li>\n</ul>\n<p>在阳光充足没有人造光源的室外，有很多物体能遮挡阳光形成阴影区域，这些阴影区域内的物体不能发光且并不能直接被阳光照射到，按道理应该是漆黑一片才对，但实际上这些阴影区域仅仅只是比周围暗一点而已；究其原因则是因为存在<code>环境光</code>，对应 ThreeJS 框架中的<code>AmbientLight</code>环境光；</p>\n<p>环境光没有明确的光源位置，在各处形成的亮度也被看作是一致的，光照颜色会添加到整个场景和所有对象的当前颜色上。</p>\n<p>示例中创建光源时使用了<code>PointLight</code>点光源和<code>AmbientLight</code>环境光：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> pointLight;\n<span class="hljs-keyword">var</span> ambientLight;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initLight</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">//点光源</span>\n    pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>( <span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span> );\n    pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">70</span>, <span class="hljs-number">112</span>, <span class="hljs-number">98</span>);\n    <span class="hljs-comment">//环境光</span>\n    ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>( <span class="hljs-number">0x333333</span> );\n}\n</code></pre>\n<p>调用<code>new THREE.PointLight(color, intensity, distance, decay)</code>即可创建一个点光源，其参数意义如下：</p>\n<ul>\n<li><code>color</code>表示光照的颜色；</li>\n<li><code>intensity</code>表示光照强度；</li>\n<li><code>distance</code>表示最远的照射距离，超过该距离后不再有任何光线；</li>\n<li><code>decay</code>表示光照的衰减程度，设置的越大则光照随着距离的增加衰减的越厉害；</li>\n</ul>\n<p>示例中点光源颜色为<code>白色</code>，强度为<code>1</code>，最远光照距离为<code>2000</code>，位置被设置在<code>点(70, 112, 98)</code>；</p>\n<blockquote>\n<p>在 ThreeJS 框架中有个非常基础的对象<code>Object3D</code>，该对象拥有<code>position</code>属性来表示其位置；框架中其它大部分对象都是由该对象扩展，比如上文中的<code>PerspectiveCamera</code>透视投影相机以及\n<code>PointLight</code>点光源。</p>\n</blockquote>\n<p>环境光只有一个颜色性质，直接调用<code>new THREE.AmbientLight( 0x333333 )</code>创建即可。</p>\n<h2 data-id="heading-7">创建物体</h2>\n<p>ThreeJS 框架中封装实现了很多种几何体，例子中使用<code>BoxGeometry</code>，该对象可以用来创建正方体或者长方体；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> cube;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initObject</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>( <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);\n    <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>( {<span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>} );\n    cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>( geometry, material );\n    cube.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);\n}\n</code></pre>\n<p>示例中初始化<code>BoxGeometry</code>对象时只用了前三个参数，分别表示<code>长</code>、<code>宽</code>、<code>高</code>；但其实该对象还有三个参数：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">BoxGeometry</span>(width, height, depth, widthSegments, heightSegments, depthSegments)\n</code></pre>\n<p>在 ThreeJS 官网中有该对象的简单示例，地址为<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2Findex.html%23api%2Fen%2Fgeometries%2FBoxGeometry" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/docs/index.html#api/en/geometries/BoxGeometry" ref="nofollow noopener noreferrer">threejs.org/docs/index.…</a></p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/1668502a64712a63~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>你会发现<code>widthSegments</code>、<code>heightSegments</code>、<code>depthSegments</code>这三个参数共同决定了不同面由多少个三角形组成；</p>\n<p>至于<code>为什么正方体盒子会由很多三角形构成？</code>可以类比于人在纸上手动画正方体，绘制正方体的过程其实就是在八个顶点间连线的过程，每四个顶点组成一个正方形面，最终由六个正方形面组成正方体；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/13/1670be64dad1a95d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在计算机中构建 3D 物体也是如此，只不过采用的是连接三个顶点组成三角形的方式而已，这个三角形在计算机图形学中被称为<code>三角形网格</code>；</p>\n<p>一般来说网格面数越多，物体越精细，但同时会消耗更多的存储空间以及计算机性能。</p>\n<blockquote>\n<p>之所以采用三角形网格则是因为三角形网格具有很多优点，比如三角形是最简单的多边形、三角形经过多种变换之后依然是三角形等等。</p>\n</blockquote>\n<p><code>三角形网格</code>只能描述物体的轮廓，但现实生活中的物体，人眼除了能看到其轮廓之外，还能看到其<code>材质</code>，比如一般情况下人能通过眼睛分辨出哪些金属哪些不是金属，因为金属和非金属对光的反射效果不一样；可以理解为<code>材质主要是用来描述物体表面动态属性的对象</code>，比如处理光照等。</p>\n<p>示例中物体使用的是<code>MeshLambertMaterial</code>兰伯特材质，这是一种非光滑表面材质没有高亮的镜面反射，初始化时设置其颜色为<code>红色</code>；</p>\n<p>最终<code>轮廓</code>和<code>材质</code>共同生成一个物体，并设置其中心点在坐标系原点。</p>\n<blockquote>\n<p>虽然示例中并不涉及，但是仔细思考就能发现<code>轮廓</code>和<code>材质</code>并不能完全描述现实中的物体，比如同一种材质的纸可以被印上不同的图案，这种物体表面的静态属性使用<code>纹理</code>对象来描述。</p>\n</blockquote>\n<p>另外还补充一点：</p>\n<blockquote>\n<p>虽然在 ThreeJS 框架中提供了很多几何体对象，但是实际开发时针对一些复杂的物体或者动画依然需要使用特定的 3D 软件设计制作并导出<code>模型</code>素材，有点类似于在网页重构中有些图案、效果或者动画很难通过代码来实现，这时候就需要用到图片素材；图片有很多种格式，有些格式比如<code>PNG</code>、<code>JPG</code>是静态图片，有些格式比如<code>GIF</code>、<code>APNG</code>是动态图片，有些格式兼容性好，有些格式兼容差；3D 模型的情况也基本类似如此，由于目前了解不多就不过多展开了。</p>\n</blockquote>\n<h2 data-id="heading-8">创建场景</h2>\n<p>到目前为止四个关键因素已经创建完成了，这时候执行代码会发现页面一片漆黑什么也没有；</p>\n<p>之所以会这样是因为在 ThreeJS 框架中创建好关键因素之后需要把它们放入<code>场景</code>中，然后再执行渲染器的渲染方法；</p>\n<p>因此需要在<code>createWorld</code>方法中新增两个方法，分别用来<code>初始化场景</code>以及<code>执行渲染</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//模拟现实场景</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorld</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-title function_">initRender</span>();<span class="hljs-comment">//创建渲染器</span>\n    <span class="hljs-title function_">initCamera</span>();<span class="hljs-comment">//创建相机</span>\n    <span class="hljs-title function_">initLight</span>();<span class="hljs-comment">//创建光源</span>\n    <span class="hljs-title function_">initObject</span>();<span class="hljs-comment">//创建物体</span>\n    <span class="hljs-title function_">initScene</span>();<span class="hljs-comment">//创建场景</span>\n    <span class="hljs-title function_">render</span>();<span class="hljs-comment">//渲染</span>\n}\n</code></pre>\n<p>在 ThreeJS 框架中<code>Scene</code>对象表示<code>场景</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> scene;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initScene</span>(<span class="hljs-params"></span>){\n    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();\n    scene.<span class="hljs-title function_">add</span>(pointLight);\n    scene.<span class="hljs-title function_">add</span>(ambientLight);\n    scene.<span class="hljs-title function_">add</span>(cube);\n}\n</code></pre>\n<p>创建场景时不需任何参数，直接执行<code>new THREE.Scene()</code>即可，然后还需要执行其<code>add</code>方法，把<code>光源</code>、<code>物体</code>添加到<code>场景</code>中；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){\n    renderer.<span class="hljs-title function_">clear</span>();\n    renderer.<span class="hljs-title function_">render</span>(scene, camera);\n    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.005</span>;\n    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.005</span>;\n    <span class="hljs-title function_">requestAnimationFrame</span>(render);\n}\n</code></pre>\n<p>渲染时需要先执行渲染器的<code>clear</code>方法清空上一次的渲染结果，然后再执行<code>render</code>方法，参数为<code>场景</code>对象以及<code>相机</code>对象；</p>\n<p><code>requestAnimationFrame</code>是浏览器提供的动画函数，浏览器会在下次重绘前执行其回调函数；</p>\n<p><code>cube.rotation.x</code>和<code>cube.rotation.y</code>的递增则是为了让方块在<code>X轴</code>和<code>Y轴</code>上不断旋转，从而形成动态的光影效果；</p>\n<p>至此整个例子就结束了。</p>\n<h2 data-id="heading-9">总结</h2>\n<p>上述内容非常基础，如果想要了解的更多，个人感觉还需要从两方面入手：</p>\n<h3 data-id="heading-10">1. 基础</h3>\n<p>包括 ThreeJS 框架使用的底层技术<code>WebGL</code>以及<code>3D数学基础</code>；</p>\n<p><code>WebGL</code>的内容会在后续章节进行简单的介绍，<code>3D数学基础</code>相关内容在整个教程中均有涉及，但如果想要系统的了解，个人推荐<code>《3D数学基础：图形与游戏开发》</code>这本书；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166851766598fb53~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h3 data-id="heading-11">2. 应用</h3>\n<p>ThreeJS 官网地址为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/" ref="nofollow noopener noreferrer">threejs.org/</a>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166851866f4b4e9f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>其中比较常用的为<code>documentation</code>和<code>examples</code>；</p>\n<p><code>文档</code>（ documentation ）包含框架中大部分对象的属性以及方法的说明信息，还一些新手入门的指引文档，比如：创建一个场景、画线、加载 3D 模型等；</p>\n<p><code>例子</code>（ examples ）顾名思义全是各种各样的例子，比如：衣服动画例子等；</p>\n<p>官网的这些资料很重要，它们能有效的帮助你从入门进阶到熟练甚至精通。</p></div>',
  },
  {
    name: "2\n数学基础\n学习时长: 47分28秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">数学基础</h1>\n<p>如标题所言都是些很基础但是异常重要的数学知识，如果不能彻底掌握它们，在 3D 的世界中你将寸步难行。</p>\n<h2 data-id="heading-1">坐标系</h2>\n<h4 data-id="heading-2">世界坐标系</h4>\n<p>在构建 3D 场景时我们需要一个坐标系来描述场景中所有点的坐标，这个坐标系也被称为世界坐标系；一般默认为你面朝计算机屏幕时，X 轴是水平的（正方向为右），Y 轴是垂直的（正方向为上），Z 轴垂直于屏幕（正方向为外）。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aab5400dfc924a66af31b10c9a3b411a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.2-1.jpg" loading="lazy" class="medium-zoom-image"></p>\n<p>它可以通过上图所示的右手手势确定（右手定则），即当你伸出右手摆出如图所示手势时，拇指指向 X 轴的正方向，食指指向 Y 轴的正方向，中指指向 Z 轴的正方向，因此这种坐标系也被称为右手坐标系。</p>\n<blockquote>\n<p>后续如果没有特殊说明，所有涉及的点、向量、坐标轴、矩阵等都是基于场景中的世界坐标系。</p>\n</blockquote>\n<h4 data-id="heading-3">物体坐标系</h4>\n<p>物体坐标系又被称为自身坐标系，在 3D 场景中每个物体都有它们独立的坐标系，物体和它的自身坐标系的关系不会随着物体在世界坐标系中的变换而变化，举例来说：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce02797d755a4b56bffab894e967eae0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.6-4.jpg" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 <code>X-Y-Z</code> 坐标系是世界坐标系，<code>X1-Y1-Z1</code> 坐标系为小方块的自身坐标系，刚开始左侧小方块的自身坐标系的 X1 轴、Y1 轴、Z1 轴和世界坐标系的 X 轴、Y 轴、Z 轴方向相同；但是当小方块绕着自身坐标系的 X1 轴向下旋转 90 度之后，如上图中右侧所示其自身坐标系也会跟着小方块旋转，因此小方块和它的自身坐标系的关系并没有变化。</p>\n<p>理论上来说只需要一个世界坐标系就可以描述场景中所有点的位置以及所有不同位置物体间的关系了，为什么还需要引入物体坐标系呢？</p>\n<p>主要原因在于人们发现不同情况下使用不同的坐标系会更加方便，比如：人在书桌上操作电脑这一场景，虽说以地球上的世界坐标系（经纬度）来分别描述人和电脑的位置也可以，但是通过这两个经纬度很难直观的得到人和电脑的位置关系；如果以人的自身坐标系来描述电脑的位置（正前方 40 厘米）就相对直观方便了很多。</p>\n<h2 data-id="heading-4">向量</h2>\n<p><code>向量</code>是一个基础且重要的数学工具，<code>从几何意义上来说主要用来描述事物间的位移以及指示方向</code>，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e198f70930c442b8f971817f80d3105~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.3-4.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图 XY 坐标系中 A 点坐标为 （x1，y1），B 点坐标系为 （x2，y2），从 B 点移动到 A 点时，位置的变化即为<code>向量 BA</code>。</p>\n<p>简单来说<code>向量是既有大小又有方向的线段</code>，从 B 点移动到 A 点的方向也就是图中箭头所示的方向即为向量 BA 的方向，线段 BA 的长度即为向量 BA 的大小。</p>\n<p>从数学表现形式上来看向量就是一个数字列表，列表中的每个数表示在不同维度上的有向位移，还是以向量 BA 为例：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e310d67e8bf494c9eeeea974c7a05eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.3-5.png" loading="lazy" class="medium-zoom-image"></p>\n<p>从 B 点移动到 A 点，在 X 轴上位置的变化为 <code>x1-x2</code>，在 Y 轴上位置的变化为 <code>y1-y2</code>，把这两个维度上的位置的变化组合在一起最终形成了二维向量 BA；图中 BA 上方的箭头表示向量的方向是从 B 点移动到 A，有些时候不标记出来则默认前面是起始点后边是终止点。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c025a50ac994fe28d3615e9f24654ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.3-6.png" loading="lazy" class="medium-zoom-image"></p>\n<p>向量数字列表有两种组织方式，水平组织的为<code>行向量</code>，垂直组织的为<code>列向量</code>；行向量和列向量的区别体现在和矩阵的乘法中，因为涉及到矩阵，这里就不过多展开了；向量运算和矩阵相关知识将会在<code>第二小节</code>进行详细讲解。</p>\n<p>回到示例图，当从 O 点移动到 B 点时，可以用向量 OB 来表示；因为 O 点为坐标系原点，其坐标值为 （0，0），分别计算向量 OB 在 X 轴和 Y 轴的有向位移，写成行向量的形式如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e84c14d600428195ddce86aaf02a94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.3-7.png" loading="lazy" class="medium-zoom-image"></p>\n<p>向量 OB 恰好和 B 点坐标是一致的，因此可以理解向量和点在概念上完全不同，但是在数学形式上却是等价的；这也就是为什么 ThreeJS 框架中 <code>Vector3</code> 类型既可以用来表示三维向量又可以用来表示三维坐标系中的点，其实际含义和具体的使用场景有关。</p>\n<blockquote>\n<p>三维、四维向量和二维向量的定义、性质基本类似，区别仅在于维度不一样。</p>\n</blockquote>\n<h4 data-id="heading-5">向量的大小</h4>\n<p>向量的大小也就是向量的长度，也被称为向量的<code>模</code>。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0062befb36d4c2daaee609435830f1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 1.2.3-4.png" loading="lazy" class="medium-zoom-image"></p>\n<p>以上图中 BA 向量为例，其长度也就是模，通常记为 <code>||BA||</code>，根据<code>直角三角形求斜边长公式</code>可得：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c05e51ac1074327ab67549c074dc741~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-8.png" loading="lazy" class="medium-zoom-image"></p>\n<p>对于任意向量，模的大小等于其每个维度数值的平方和然后开根号；这也就是 ThreeJS 框架中各向量类型计算长度的 <code>length</code> 函数的实现，以二维向量 Vector2 为例（其中 x 和 y 表示二维向量在 X 轴和 Y 轴的有向位移）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ded20fa01c3d4f699166b7c38f6129bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-3.png" loading="lazy" class="medium-zoom-image"></p>\n<p>你可能有点疑惑了，本文标题写的是 <code>3D</code>，但是文中例子却都基于 2D 坐标系？主要原因在于 2D 坐标系相对于 3D 坐标系更简单更容易理解（降维打击），<code>虽然 3D 比 2D 多一个维度，但基本数学规律却是类似的</code>；</p>\n<p>比如求三维向量 Vector3 的长度，同样也是计算每个维度数值的平方和然后开根号，和二维向量 Vector2 唯一的区别仅仅在于多出一个维度而已；</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02217d704584f4b8047ab76900de3f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-4.png" loading="lazy" class="medium-zoom-image"></p>\n<p>类似的例子还有很多，就不一一列举了；本人对于图形编程的入门经验在于<code>快速理解立即实践</code>；不管是框架还是数学知识都是这种思路，<code>具体来说对于数学知识理解即可、拿来即用、有必要才去推导，对于框架重点掌握关键知识点搭建整体轮廓</code>。</p>\n<h4 data-id="heading-6">负向量</h4>\n<p>和原向量<code>大小相等，方向相反</code>的向量为原向量的负向量，要得到任意向量的负向量，只需要简单地将原向量每个维度数值取负即可：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7755f825b246af97a00b6448c14ad7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-25.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-7">零向量</h4>\n<p><code>零向量</code>是大小为 0 的向量。</p>\n<h4 data-id="heading-8">单位向量</h4>\n<p><code>单位向量</code>就是大小为 1 的向量，也被称为<code>标准化向量</code>；对任意非零向量都能计算出一个和它方向相同的单位向量，对应 ThreeJS 框架中 Vector2、Vector3、Vector4 提供的 <code>normalize</code> 方法。</p>\n<h4 data-id="heading-9">法向量</h4>\n<p>垂直于平面的直线所表示的向量为该平面的<code>法向量</code>，比如：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480cdd0c8dd9481b8366d776bb0ffa39~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-1.png" loading="lazy" class="medium-zoom-image"></p>\n<p>在上述三维坐标系中 AB 向量和 CD 向量方向相同（均指向 Y 轴正方向），因此 AB 向量和 CD 向量垂直于 XZ 平面，那么 AB 向量和 CD 向量都是 XZ 平面的法向量；需要注意的是垂直于某个平面的直线可以画出无数条，这也就意味着某个平面的法向量也会有无数个。</p>\n<p>向量可以指示方向，比如法向量就指示出了平面的朝向，利用这一性质就可以对光照模型进行数学建模：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fc3ee4f8d964dafb5437fe13efc266c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-9.png" loading="lazy" class="medium-zoom-image"></p>\n<p>在光的反射模型中，入射光可以看成入射向量，反射光可以看成反射向量，而法线垂直于反射面可以看成是反射面的法向量；根据实际问题建立数学模型，然后就可以进行求解了，详细过程<code>可能</code>会在 WebGL 相关文章中进行讲解，这里就不过多展开了。</p>\n<h4 data-id="heading-10">向量相等</h4>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041818fd13954c82b39d86bfd58b0e7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-10.png" loading="lazy" class="medium-zoom-image"></p>\n<p>示例图中 AB 向量和 CD 向量<code>大小相等、方向相同</code>，那么它们就是相等的；除了上述判断方法之外，还可以平移 AB 向量至坐标系原点，此时 AB 向量将和 CD 向量完全重合，因此它们是相等的，这也说明<code>向量和位置无关</code>。</p>\n<h4 data-id="heading-11">向量相加</h4>\n<p>相同维度的两个向量可以进行相加，结果向量的维度与原向量相同且每个维度数值为两个相加向量对应维度数值之和，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72797472351451c826ba5bed4110ec4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-5.png" loading="lazy" class="medium-zoom-image"></p>\n<p>向量加法满足<code>三角形法则</code>和<code>交换律</code>，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5084b0291f204e36aa3cfa2235dcc011~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-11.png" loading="lazy" class="medium-zoom-image"></p>\n<p>OA 向量加 OB 向量，可以平移 OB 向量，用 OB 向量的尾连接 OA 向量的头，得到 AC 向量；接着从 OA 向量的尾向 AC 向量的头画一个 OC 向量，该向量就是 OA 向量加 OB 向量的结果向量；<code>两个相加向量和其结果向量平移之后刚好会组成一个三角形</code>，这就是向量加法的三角形法则。</p>\n<p>此外交换相加向量位置并不影响结果，比如说 OB 向量加 OA 向量，此时需要平移 OA 向量至 BC 向量，根据三角形法则结果向量依然是 OC 向量，也就是说向量加法满足交换律。</p>\n<p>向量可以用来描述事物间的位移，数字列表中的每一项表示在不同维度上的有向位移，而向量相加则是对这种位移的累加，比如：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf33cbecec314fe6a784f75a586f499b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-6.png" loading="lazy" class="medium-zoom-image"></p>\n<p>OA 向量表示在 X 轴正方向上移动 1 个单位和在 Y 轴正方向上移动 2 个单位，而 OB 向量表示在 X 轴正方向上移动 2 个单位和 Y 轴正方向上移动 1 个单位，那么它们的结果向量就是对它们在 X 和 Y 轴上的位移的累加，也就是说结果向量 AC 表示在 X 轴正方向上移动 3 个单位且在 Y 轴正方向上也移动 3 个单位。</p>\n<h4 data-id="heading-12">向量相减</h4>\n<p>相同维度的两个向量还可以进行相减，结果向量的维度依然和原向量相同，但是每个维度数值为两个相减向量对应维度数值之差，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934fb83669f2407fbfd9ed638104a397~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-7.png" loading="lazy" class="medium-zoom-image"></p>\n<p>向量减法同样满足三角形法则，但是和加法有点细微的差别，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6c9be1bb3a4bd1820a588387990c2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-12.png" loading="lazy" class="medium-zoom-image"></p>\n<p>还是 OA 和 OB 两个向量，但是这次执行减法操作；OA 向量减 OB 向量，平移 OB 向量，使 OB 向量的头连接 OA 向量的头，得到 CA 向量；接着从 OA 向量的尾向 CA 向量的尾画一个 OC 向量，该向量就是 OA 向量减 OB 向量的结果向量，这就是向量减法的三角形法则；和加法三角形法则的区别在于<code>加法三角形法则是平移的被加向量和加向量头尾相连，而减法三角形法则是平移的被减向量和减向量头头相连</code>。</p>\n<p>加法满足交换律，但是减法并不满足，具体可以看图中 OB 向量减 OA 向量的结果为 OD 向量。</p>\n<h4 data-id="heading-13">向量相乘</h4>\n<p>向量除了可以相加和相减，还可以进行相乘；向量有两种乘法类型，分别为<code>点乘</code>和<code>叉乘</code>：</p>\n<ul>\n<li>点乘</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073800b78c64415283165dcd7749fb22~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-23.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 A 点坐标为（x1，y1），B 点坐标（x2，y2），OA 向量和 OB 向量夹角为 θ。</p>\n<p><code>向量点乘就是相乘向量每个维度数值乘积的和</code>，那么 OA 向量和 OB 向量的<code>点乘</code>（一般使用点符号 <code>·</code> 来标识这种运算）结果如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b49c83bb45f64f8f8719b3496d07bfa6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-13.png" loading="lazy" class="medium-zoom-image"></p>\n<p>另外<code>从几何意义上来说向量点乘等于两个向量的大小与向量夹角的 cos 值的积</code>，那么 OA 向量和 OB 向量的点乘结果又等于：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c87721311854a23b42c7a3b5c908bb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-14.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上述两个结果是相等的，证明如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52de69b3388f4bff89e7cbdcb548cc4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-15.png" loading="lazy" class="medium-zoom-image"></p>\n<p>因此向量点乘有一个非常常用的应用，即求两个向量的夹角。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8d314db54c3458d8543baeb92895fe8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-16.png" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>叉乘</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e4427830c42f0ba95533647cde115~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-17.png" loading="lazy" class="medium-zoom-image"></p>\n<p>向量叉乘<code>仅适用于三维向量</code>，和点乘不一样，向量叉乘的结果也是一个向量，其大小等于叉乘向量组成的平行四边形面积大小，方向同时垂直于叉乘向量且满足<code>右手定则</code>；根据其性质向量叉乘<code>常用于三维坐标系求平面法向量、以及判断两个向量的左右关系</code>等。</p>\n<p>如图所示向量 OA 和 向量 OB 叉乘结果为 OC 向量；OC 向量既垂直于 OB 向量也垂直于 OA 向量，同时其大小等于 OA 向量和 OB 向量组成的平行四边形面积大小。</p>\n<p>另外对于 OA 向量叉乘 OB 向量；根据右手定则，大拇指指向 OA 向量的方向，食指指向 OB 向量的方向，那么中指指向的即是它们叉乘结果向量 OC 的方向；反之当 OB 向量叉乘 OA 向量时，同样根据右手定则，大拇指指向 OB 向量的方向，食指指向 OA 向量的方向，此时中指指向的是 OD 向量的方向；从上述规律中不难看出<code>当某个向量叉乘的另外一个向量在其左侧时，它们的叉乘结果向量方向和平面法向量方向一致，而当某个向量叉乘的另外一个向量在其右侧时，它们的叉乘结果向量方向和平面法向量方向相反</code>。</p>\n<p>已知两个向量的左右关系，可以解决很多经典的图形学问题，比如求解空间中的点是否在某个三角形（凸多边形）内、把凹多边形拆分为多个凸多边形等。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20e2df87c904d828d67b9f8bd9869fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-28.png" loading="lazy" class="medium-zoom-image"></p>\n<p>左图中对于三角形任意边向量（AB、BC、CA）而言，其起始点和空间中点 D 组成的向量始终在边向量的左侧，那么该点 D 在三角形内部；</p>\n<p>右图中对于任意凹多边形依次连接其顶点组成边向量，然后判断前一个边向量是否在后一个边向量的左侧，如果是则根据后边的边向量划分该凹多边形，依次类推即可把凹多边形拆分为多个凸多边形。</p>\n<p>回归正题，OB 向量和 OA 向量夹角为 θ，根据平行四边形面积计算公式可得 OC 向量的模：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a645716ea64a9b96248f8a4a10fe1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-18.png" loading="lazy" class="medium-zoom-image"></p>\n<p>根据叉乘的定义可以推导出叉乘具备如下性质：</p>\n<ul>\n<li>相等向量叉乘结果为 0 向量；</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d931a66f50fc4a989ea633c651bea8f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-19.png" loading="lazy" class="medium-zoom-image"></p>\n<p>相等向量完全重合，它们组成的平行四边形面积为 0，也就是说它们叉乘的结果向量大小为 0，大小为 0 的向量即为 0 向量。</p>\n<ul>\n<li>缩放叉乘向量中的某个向量，其结果向量也会被缩放相同倍数；</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2219f83c099f4758aa06972e595cf258~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-20.png" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>叉乘分配律，向量和的叉乘等于向量叉乘的和；</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c51841a397140458bee2654032375f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-21.png" loading="lazy" class="medium-zoom-image"></p>\n<p>这个性质相对来说比较难以理解，但并不是没有<code>取巧</code>的办法；<code>有时候如果某个性质一般情况比较难以理解的话，可以直接查看其特例</code>，如下：</p>\n<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45bdca50ae7d4f31baf3e3d571103c44~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-22.png" loading="lazy" class="medium-zoom-image"></p>\n<p>如上图所示，OE 向量、OF 向量、OG 向量分别在 Y 轴、X 轴、Z 轴上，彼此垂直；把这三个向量代入到公式中，可以很明显的看到叉乘分配律是成立的；比如 OF 向量 和 OG 向量相加得到 OH 向量，OH 向量和 OE 向量叉乘最终结果为 OJ 向量；拆看来看 OF 向量 和 OE 向量叉乘得到 OG 向量，OG 向量和 OE 叉乘得到 OI 向量，而 OG 向量和 OI 向量相加最终结果也是 OJ 向量。</p>\n<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d16bb5c168104b4ab1a6559ad502cfed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-23.png" loading="lazy" class="medium-zoom-image"></p>\n<p>也就是说对于 OE、OF、OG 这三个长度为 1 且互相垂直的向量来说叉乘分配律是成立的。</p>\n<p>需要注意上面的特例仅仅只是本人在学习过程中偷懒取巧的做法，主要是为了方便理解，并没有证明叉乘分配律；要想证明叉乘分配律可以取<code>任意</code>三个向量，然后加入一些辅助手段观察其规律，和特例中的做法是类似的，有兴趣的同学可以尝试一下。</p>\n<p>介绍了叉乘的几何意义以及一些基础性质，接下来求叉乘的具体计算规则，即已知 A 点坐标（x1，y1，z1），B 点坐标（x2，y2，z2）求 OA 向量和 OB 向量叉乘的结果 OC 向量的具体坐标。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a5659b07ce146b5b64eeb29e4a649d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-17.png" loading="lazy" class="medium-zoom-image"></p>\n<p>首先假设 X、Y、Z 轴上的单位向量分别为 <code>i、j、k</code>：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70cfa2b11b814afbb3c54521edc1e0ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-24.png" loading="lazy" class="medium-zoom-image"></p>\n<p>OA 向量和 OB 向量可以写成由 i、j、k 向量相加的形式：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd8cb20a993480eac1cd16f19f27287~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-26.png" loading="lazy" class="medium-zoom-image"></p>\n<p>根据叉乘分配律拆分，最终求出叉乘结果向量 OC 的具体坐标如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/733a5dc270184e4e92e366890a5ce307~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.1-27.png" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-14">矩阵</h2>\n<p>矩阵 <code>Matrix</code> 在《黑客帝国》中是一个用来囚禁人类的虚拟世界，非常神秘且强大，而我们后续所要讨论的矩阵同样具有强大的特性，它是 3D 数学中非常重要且基础的工具。从表现形式上看矩阵是如下图所示的以<code>行</code>和<code>列</code>形式组织的矩形数字块。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a4f350f4757413590e34bd25be6a26b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-2.png" loading="lazy" class="medium-zoom-image"></p>\n<p>一个 <code>M X N</code> 矩阵是一个用圆括号包起来的含有 M 行、N 列的矩形数字块，比如上图中的两个矩阵则分别是 <code>2 X 2</code> 矩阵 和 <code>3 X 3</code> 矩阵；行数和列数相同的矩阵也被称为<code>方阵</code>，ThreeJS 框架中三阶矩阵 Matrix3 为 <code>3 X 3</code> 方阵，四阶矩阵 Matrix4 为 <code>4 X 4</code> 矩阵；另外矩阵的行数和列数可以是任意正整数，这也就意味着<code>行向量可以看作是行数为 1 的矩阵，列向量可以看作是列数为 1 的矩阵</code>。</p>\n<p>有时候人们也会使用<code>方括号</code>包含数字块来表示矩阵，这也是被允许的；矩阵真正重要的是它的性质而不是其外形。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f44b9f2eafc34c189b22b15175c5e616~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-21.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-15">矩阵乘法</h4>\n<p>矩阵可以和标量相乘，矩阵可以和矩阵相乘，另外行数或者列数为 1 的矩阵等价于向量，那么矩阵也可以和向量相乘。</p>\n<ul>\n<li>标量乘以矩阵，即标量乘以矩阵中的每个元素，最终结果为一个新的矩阵，如下：</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e5236ee6ea4a53b6794db54f47818b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-7.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 k 为标量，M 为矩阵。</p>\n<ul>\n<li>矩阵乘以矩阵，两个矩阵相乘需要满足一定的条件；举例来说矩阵 M 乘以矩阵 N，需要满足矩阵 M 的列数等于矩阵 N 的行数；如下：</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c998db5e614547df9d6a924604b406ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-8.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 M 为 <code>3 X 2</code> 矩阵，N 为 <code>2 X 2</code> 矩阵，矩阵 M 的列数等于矩阵 N 的行数，因此矩阵 M 可以乘以矩阵 N 得到的新矩阵 G；新矩阵 G 行数等于矩阵 M，列数等于矩阵 N；同时新矩阵 G 中第 i 行第 j 列的元素等于矩阵 M 第 i 行的元素和矩阵 N 第 j 列的元素一一相乘之后的和；如图中所示新矩阵 G 第 1 行第 2 列的元素为 <code>m11 * n12 + m12 * n22</code> 以此类推。</p>\n<h4 data-id="heading-16">矩阵变换</h4>\n<p>在 3D 数学中矩阵的强大表现在使用矩阵我们可以很方便的进行变换，举例来说：</p>\n<ul>\n<li>旋转</li>\n</ul>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce69ffdfd5349039ccd57a4626fc4e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-23.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中我们把 OA 向量以原点 O 为基准点逆时针旋转 θ 度得到 OB 向量，已知 A 点坐标为（x1，y1），求 B 点坐标（x2，y2）。</p>\n<p>首先旋转并不会改变向量的大小，因此 OA 向量和 OB 向量大小均为 <code>L</code>：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26eaf30003e54db992ab2c4d11658e57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-1.png" loading="lazy" class="medium-zoom-image"></p>\n<p>设 OA 和 X 轴之间的夹角为 <code>α</code> 那么：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb4809ef61247edbeda422d25441a9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-9.png" loading="lazy" class="medium-zoom-image"></p>\n<p>再设 OB 和 X 轴之间的夹角为 <code>β</code> 那么：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07a1e1bf3b484004b1f8e98bbb40119d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-10.png" loading="lazy" class="medium-zoom-image"></p>\n<p>根据上述已知变量和三角函数公式可以计算出 B 点坐标（x2，y2）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5621df80be7f4e64b9ba490c5b829530~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-11.png" loading="lazy" class="medium-zoom-image"></p>\n<p>此时如果我们把旋转之前的 OA 向量写成行向量形式（x1，y1），同时也是 <code>1 X 2</code> 的矩阵乘以某个 <code>2 X 2</code>的矩阵，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3616ce69bb084e0d8dfd4a83e01fcd21~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-12.png" loading="lazy" class="medium-zoom-image"></p>\n<p>在上述矩阵乘法中如果 <code>m11=cosθ、m21=-sinθ、m12=sinθ、m22=cosθ</code> 那么把得到的新的 <code>1 X 2</code> 矩阵看成行向量，它和 OA 向量旋转之后得到的 OB 向量是一样的，这也就说<code>旋转变换可以用矩阵乘法来计算</code>。</p>\n<p>二维坐标系中以原点为基准点逆时针旋转 θ 角可以表示为如下矩阵：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f0adaa5e6284193af5f88b354da479f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-13.png" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>缩放</li>\n</ul>\n<p>旋转变换可以用矩阵乘法来计算，同理缩放变换也可以，举例来说：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafbbaeffac4408390276ea0278ee9fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-24.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 OA 向量以原点 O 为基准点缩短为原来的 n 倍得到 OB 向量，已知 A 点坐标为（x1，y1），求 B 点坐标（x2，y2）。</p>\n<p>根据等比缩放很容易就可以得到 B 点坐标，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d0f17dcac848849163ef1cb20fcde7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-14.png" loading="lazy" class="medium-zoom-image"></p>\n<p>再次代入矩阵乘法：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1d187a82ca464aa5f3a3ad40818120~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-12.png" loading="lazy" class="medium-zoom-image"></p>\n<p>当 <code>m11=n、m21=0、m12=0、m22=n</code> 那么把得到的新的 <code>1 X 2</code> 矩阵看成行向量，它和 OA 向量缩短之后得到的 OB 向量也是一样的，即证<code>缩放变换也可以用矩阵乘法来计算</code>。</p>\n<p>二维坐标系中以原点为基准点缩放为原来的 n 倍可以表示为如下矩阵：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0556b3913bc94c2cad4c88ab8603f1b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-15.png" loading="lazy" class="medium-zoom-image"></p>\n<ul>\n<li>组合变换</li>\n</ul>\n<p>上述变换都是单一变换，把多个单一变换组合到一起，依然是可以用矩阵来进行计算的，组合变换矩阵即为单一变换矩阵的乘积。</p>\n<p>举例来说，当先进行旋转再进行缩放，其最终变换矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48cacc3ba6244c0d9663962451bb8c8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-16.png" loading="lazy" class="medium-zoom-image"></p>\n<p>到这里大家应该明白了矩阵的强大之处了，即矩阵能描述任意<code>线性变换</code>，而任意线性变换的组合可以表示为矩阵连乘的形式。</p>\n<h4 data-id="heading-17">线性变换</h4>\n<p>在矩阵变换中引入了一个新概念 <code>线性变换</code>，简单来说如果坐标系中的所有直线进行变换之后依然还是直线且坐标系原点进行变换后并没有变化，那么就可以认为这个变换是线性变换。</p>\n<p>常见的线性变换有<code>旋转</code>、<code>缩放</code>等；得稍微注意一点，并不是任意旋转和缩放都是线性变换，准确得说是<code>以坐标系原点为基准点的旋转和缩放才是线性变换</code>，举例来说：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdbef88c8fa4f46901932eb7114bcc0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-25.png" loading="lazy" class="medium-zoom-image"></p>\n<p>图中 OA 以 OA 上的某点 C 为基准点顺时针旋转 α 得到 BD，此时这个旋转变换会改变坐标系的原点，因此不属于线性变换；而当 OA 以原点为基准点顺时针 β 得到 OE，此时原点并没有发生变换，因此属于线性变换。</p>\n<p>另外特别特别需要注意<code>平移</code>并不是线性变换，因为平移会改变坐标系原点，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b7f76b5cd44947b5efd6b558d65caf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-26.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图中 OA 向量沿着 X 轴正方向平移一定距离 m 得到 CB 向量，已知 A 点坐标为（x1，y1），求 B 点坐标（x2，y2）。</p>\n<p>沿着 X 轴正方向平移并不会改变 Y 轴坐标，而 X 轴坐标系为原有坐标加上平移距离，因此得到 B 点坐标，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/492a450146ae4a3b88da5253d9d535a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-17.png" loading="lazy" class="medium-zoom-image"></p>\n<p>代入矩阵乘法：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7089516bc3f049ed8f4d604ba209808f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-12.png" loading="lazy" class="medium-zoom-image"></p>\n<p>我们会发现没办法求出 <code>m21</code>，目前看来是不能用矩阵来描述平移变换了。</p>\n<h4 data-id="heading-18">齐次坐标</h4>\n<p><code>齐次坐标</code>就是新增一个额外的维度，用<code>N+1</code>维来表示<code>N</code>维坐标；把坐标统一转换为齐次坐标之后就可以解决组合变换中存在平移时不能用矩阵连乘表示的问题了。</p>\n<p>首先举例说明齐次坐标，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2cc46f572e54941ab39b3194f8af215~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-27.png" loading="lazy" class="medium-zoom-image"></p>\n<p>在二维坐标系 XY 中存在一点 A 坐标为（x1，y1），我们可以把该二维坐标系放置在某个虚拟三维坐标系的特定位置，比如三维空间 W 轴 为 1 的位置，此时在这个虚拟三维坐标系中 A 点又可以表示为（x1，y1，1）；新增一个额外维度之后 A 点坐标可以表示为 <code>（x1*w，y1*w，w）</code> 的形式，即把原有坐标值乘以新增坐标值 w；同理已知齐次坐标转换为原有坐标时，只需要把齐次坐标除以新增坐标值 w 即可。</p>\n<p>A 点坐标（x1，y1）表示为 <code>（x1*w，y1*w，w）</code> 形式后随着 w 取值的变化有无数种形式，这些都是 A 点坐标（x1，y1）的齐次坐标。</p>\n<p>接着使用齐次坐标解决用矩阵表示平移变换的问题，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fc11363d4a440f98f1e0d7b87dd3f08~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-28.png" loading="lazy" class="medium-zoom-image"></p>\n<p>还是一样的问题 OA 向量沿着 X 轴正方向平移一定距离 m 得到 CB 向量，已知 A 点坐标为（x1，y1），求 B 点坐标（x2，y2）。</p>\n<p>先把 A 点坐标转换为齐次坐标（x1，y1，1），沿着 X 轴正方向平移并不会改变 Y 轴坐标，而 X 轴坐标系为原有坐标加上平移距离，因此得到 B 点齐次坐标，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd00afac9a3343af8085ed37f73c956d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-18.png" loading="lazy" class="medium-zoom-image"></p>\n<p>把 OA 向量写成行向量形式（x1，y1，1），此时是 <code>1 x 3</code> 的矩阵乘以某个 <code>3 X 3</code> 的矩阵，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c252a8853b4e8bb97943b77523e765~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-19.png" loading="lazy" class="medium-zoom-image"></p>\n<p>把得到的 B 点齐次坐标代入上述矩阵乘法，你会发现当 <code>m11=1、m21=0、m31=m、m12=0、m22=1、m32=0、m13=0、m23=0、m33=1</code> 时，二维坐标系中的平移变换也可以表示为矩阵形式了，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0405ff81e7634d6ebefdce37ac2d049c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-20.png" loading="lazy" class="medium-zoom-image"></p>\n<p>使用齐次坐标顺利把平移变换转换成矩阵形式之后，存在平移的组合变换依然不能用矩阵连乘表示；因为齐次坐标的引入导致平移变换比其它线性变换多了一个维度；以二维坐标系为例，其它线性变换矩阵为 <code>2 X 2</code> 矩阵，但是平移变换矩阵为 <code>3 X 3</code> 矩阵，根据矩阵乘以矩阵需要满足前一个矩阵的列数等于后一个矩阵的行数这一原则，它们之间是不能相乘的；解决的办法是其它线性变换也引入齐次坐标，最终得到的变换矩阵就可以相乘了。</p>\n<p>这也就是为什么处理三维问题的 ThreeJS 框架中会存在四维向量 Vector4 和四维矩阵 Matrix4 的原因了；因为三维坐标的齐次坐标为四维坐标，而四维齐次坐标对应的变换矩阵为四维矩阵。</p>\n<h4 data-id="heading-19">对角矩阵</h4>\n<p>当我们把行号和列号以下标的形式标注在矩阵元素上时；比如：第一行第一列的元素下标为 <code>11</code>，第 m 行第 n 列的元素下标为 <code>mn</code>，那么某个 <code>3X3</code> 方阵如下图所示：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6591e3b2e4d34cd893feca391fc5d39f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-4.png" loading="lazy" class="medium-zoom-image"></p>\n<p>其<code>对角线元素</code>就是方阵中行号和列号相同的元素，对应上图中的 <code>a11、a22、a33</code>；其它元素为<code>非对角线元素</code>。如果方阵中所有非对角元素均为 0，那么这个方阵也被称为<code>对角矩阵</code>，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d2e86685274d1a81049c7dc5f91f67~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-5.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-20">单位矩阵</h4>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78f16cbde63c414fa2095ccf777adc48~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-6.png" loading="lazy" class="medium-zoom-image"></p>\n<p><code>单位矩阵</code>是一种特殊的对角矩阵，其对角线元素均为 1，通常记为 <code>I</code>，任何矩阵和单位矩阵相乘都等于其本身，从矩阵变换的角度来看，即单位矩阵的矩阵变换，变换前和变换后没有变化。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b147534f395e49f49f01916608f11a53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-34.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-21">行列式</h4>\n<p>矩阵的<code>行列式</code>也是就是矩阵的<code>“大小”</code>，不过并不是所有矩阵都有大小，只有行数和列数相同的方阵才有大小；向量的大小表示向量的长度，方阵的大小则表示坐标系中<code>基向量（坐标轴单位向量）</code>经过该方阵变换后的新向量组成的<code>平行四边形的有符号面积（二维坐标系）</code>、<code>平行六面体的有符号体积（三维坐标系）</code>以此类推。</p>\n<p>以某 <code>2X2</code> 方阵 A 为例：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42ae0acb5a5450ebdfe6baba7f9b7db~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-38.png" loading="lazy" class="medium-zoom-image"></p>\n<p>二维坐标系中的基向量 X、Y 分别乘以方阵 A 得到新向量，画图表示如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4203c91e24fc4c788ba70e6b61547ab4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-39.png" loading="lazy" class="medium-zoom-image"></p>\n<p>X 轴基向量变换后的新向量为 OC，Y 轴基向量变换后的新向量为 OD，而 OC 向量和 OD 向量组成的平行四边形的<code>有符号</code>面积即为矩阵 A 的大小也就是矩阵 A 的行列式。</p>\n<p>有符号的意思是<code>可正可负</code>，在上图中变换后的基向量组成的平行四边形相对于初始基向量组成的平行四边形，位置发生了<code>翻转</code>，那么方阵 A 的行列式等于变换后基向量组成的平行四边形面积的<code>负数</code>。</p>\n<p>仔细观察上述例子中变换后的新向量 OC 和 OD 以及方阵 A，我们会发现<code>方阵其实是由变换后的基向量组合而成</code>，这一性质对于任意方阵以及任意维度都是成立的：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffef677704cb46deae26802b3cfc6184~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-40.png" loading="lazy" class="medium-zoom-image"></p>\n<p>已知方阵即可得变换后的基向量 OC、OD，再根据平行四边形面积公式求该方阵行列式：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebff637184004c83a65b5fc5b38de634~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-41.png" loading="lazy" class="medium-zoom-image"></p>\n<p>对于二维方阵来说，其<code>行列式等于对角元素的积减去反对角元素的积</code>。</p>\n<h4 data-id="heading-22">余子式、代数余子式</h4>\n<p>假设矩阵 M 有 r 行 c 列，从中任意移除某一行和某一列后剩下的有 r-1 行 c-1 的矩阵被称为矩阵 M 的<code>余子式</code>，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/693babb16d32425ebc7c3d6a1f49bc5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-37.png" loading="lazy" class="medium-zoom-image"></p>\n<p>例子中移除的是第 1 行和第 2 列，因此余子式记为 <code>{1,2}</code>，如果移除的是第 i 行和第 j 列则记为 <code>{i,j}</code>。</p>\n<p><code>代数余子式</code>等于相应余子式的有符号行列式，计算方阵 M 第 i 行、第 j 列的代数余子式如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b188261bc47f48f8b4cebbdf8b849285~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-42.png" loading="lazy" class="medium-zoom-image"></p>\n<p>计算高阶方阵的行列式需要借助余子式和代数余子式；首先从矩阵中任意选择一行或一列，对该行或该列的每个元素都乘以对应的代数余子式，然后把它们加起来得到的和即是该矩阵的行列式。</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21cbeb3beb754c31a5676b79fef78b1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-43.png" loading="lazy" class="medium-zoom-image"></p>\n<p>以三阶方阵为例：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0592d7ff5d164019970a85f340af5096~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-44.png" loading="lazy" class="medium-zoom-image"></p>\n<p>求任意高维度方阵的行列式最终都可以递归转化为求二阶方阵行列式问题。</p>\n<h4 data-id="heading-23">转置矩阵</h4>\n<p>假设存在两个矩阵 M 和 T：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01f232921b74ad3bd32d3594cf8f441~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-3.png" loading="lazy" class="medium-zoom-image"></p>\n<p>其中矩阵 T 的横行由矩阵 M 的纵行组成，而其纵行又是由矩阵 M 的横行组成，那么就称矩阵 T 为矩阵 M 的<code>转置矩阵</code>，记为：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa4ec49ebc084116ab0b520c54b41c3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-32.png" loading="lazy" class="medium-zoom-image"></p>\n<p>当转置矩阵双方均为方阵时看起来就好像是沿着对角线翻折一样。</p>\n<p>矩阵相乘的转置等于先转置矩阵然后再倒序相乘，这一结论可以扩展到任意矩阵相乘的情形：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c58a8ce4b24466885494e0880523523~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-51.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-24">标准伴随矩阵</h4>\n<p>矩阵的<code>标准伴随矩阵</code>为其代数余子式矩阵的转置矩阵，记为 <code>adj M</code>；以三阶方阵为例：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6b44403ff14dd38b9879fc62e24794~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-45.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-25">逆矩阵</h4>\n<p>给定一个 <code>n X n</code> 方阵 A，若存在另一 <code>n X n</code> 方阵 B，使得 <code>A*B = B*A = I</code>，其中 I 为 <code>n X n</code> 单位矩阵，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b256edccc304bacac0e9a89a8ff2259~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-22.png" loading="lazy" class="medium-zoom-image"></p>\n<p>那么方阵 A 是可逆的，且方阵 B 是方阵 A 的逆矩阵，用公式表示如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2287b86bf1e4b569a1857c09ca6ae08~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-35.png" loading="lazy" class="medium-zoom-image"></p>\n<p><code>逆矩阵通常用于变换还原</code>，比如某向量 V 用矩阵 M 进行变换，如果要想还原回去只需要再用矩阵 M 的逆矩阵进行变换即可：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbfe18178f44e3db9a87935838ca2b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-36.png" loading="lazy" class="medium-zoom-image"></p>\n<p>矩阵的逆矩阵等于其标准伴随矩阵除以其行列式：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c67b2a9fdddc492784c0ea45a4f05688~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-46.png" loading="lazy" class="medium-zoom-image"></p>\n<p>当矩阵的行列式为零时上述公式是没有意义的，因此并不是所有矩阵都有逆矩阵，检测行列式的值是判断矩阵是否可逆的有效方法。</p>\n<p>通过上述方法求矩阵 A 的逆矩阵详细过程如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa10bf5bfe2145089a781374dee7e083~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-47.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-26">正交矩阵</h4>\n<p>对于某个矩阵 A，如果其转置换矩阵等于其逆矩阵，则称该矩阵 A 为<code>正交矩阵</code>：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0f8cf232e24a7a99148e808a3790cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-52.png" loading="lazy" class="medium-zoom-image"></p>\n<p>已知某个矩阵为正交矩阵，那么就可以根据上述性质快速求出其逆矩阵；以旋转变换为例（旋转矩阵为正交矩阵）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/040da59b95ce4385bc6ed4e84de40a86~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-23.png" loading="lazy" class="medium-zoom-image"></p>\n<p>二维坐标系中 OA 以原点为基准点<code>逆时针旋转 θ 角</code>到 OB ，旋转矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57a90334e424d1bb1fc8197c20457fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-13.png" loading="lazy" class="medium-zoom-image"></p>\n<p>其逆矩阵也就是上述旋转的反向旋转矩阵，根据正交矩阵的性质可得 OB 以原点为基准点<code>顺时针旋转  θ 角</code>到 OA 的旋转矩阵为：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69351b3b25634f91b221e01b402878d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-53.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-27">逆转置矩阵</h4>\n<p>对某一矩阵 M 先计算其逆矩阵，再计算其逆矩阵的转置矩阵，最后得到的矩阵即为矩阵 M 的逆转置矩阵。</p>\n<p>逆转置矩阵和法向量变换有关：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c0a3aebc9c4414a94093904d9766a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-29.png" loading="lazy" class="medium-zoom-image"></p>\n<p>上图为某 3D 坐标系 Z 轴正视图，在该坐标系中存在一平面，P1、P2 为平面上两点，向量 N 为其法向量；如果该平面在 X 轴方向上缩放为原来的 0.5 倍，那平面上所有点的 X 轴坐标都缩放为原来的 0.5 倍数；但是其法向量的变换和点的变换有点不一样；如果法向量也在 X 轴上缩放 0.5 倍，那么就会变成中间图的样子，但平面法向量应该始终垂直于平面，因此实际情况应该右侧图。</p>\n<p>究其原因在于<code>法向量变换矩阵应该是顶点变换矩阵的逆转置矩阵</code>，证明过程如下：</p>\n<blockquote>\n<p>通过上述例子理解即可，证明过程能看明白最好，万一看不明白关系也不大。</p>\n</blockquote>\n<p>已知 P1、P2 为平面上两点，从点 P1 移动到点 P2 表示为向量 <code>T</code>（t1，t2，t3），平面法向量为 <code>N</code>（n1，n2，n3）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b40c2c5b0024176b573f4b14a116a1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-30.png" loading="lazy" class="medium-zoom-image"></p>\n<p>该平面经过某矩阵 M 变换后，向量 T 变为向量 <code>T\'</code> （t1\'，t2\'，t3\'），平面法向量为 <code>N\'</code>（n1\'，n2\'，n3\'）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8c4d9505af749438a839b18600949f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-31.png" loading="lazy" class="medium-zoom-image"></p>\n<p>平面法向量始终垂直于平面，那么向量 N 垂直于向量 T，向量 T\' 垂直于 N\'，也就是说它们的点乘结果为 0：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18acbf1eee9e410b9b7df8362b546c8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-33.png" loading="lazy" class="medium-zoom-image"></p>\n<p>把向量看成矩阵，同理可得：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02ca59f6da6e4de2912b8e70ce43ada7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-48.png" loading="lazy" class="medium-zoom-image"></p>\n<p>矩阵 M 和其逆矩阵相乘为单位矩阵 I，向量 T 经过矩阵 M 变换后 为 T\'：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/599d388ae2a543a1b63996080b32ded1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-49.png" loading="lazy" class="medium-zoom-image"></p>\n<p>两式相等即可得：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e97e1fa0ee45e6a8cf7b62f3e22943~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.2-50.png" loading="lazy" class="medium-zoom-image"></p>\n<p>证明完毕。</p>\n<h2 data-id="heading-28">投影</h2>\n<p>在上文中我们学习了世界坐标系和物体坐标系，理解了这两个坐标系我们就可以正确使用 ThreeJS 中的变换方法了；但是 ThreeJS 中的坐标系不仅仅只有这两种，还包括<code>相机坐标系</code>和<code>屏幕坐标系</code>。</p>\n<p>当我们在场景中加入相机并拍摄场景时，其实就相当于以相机的视角来重新描述场景，最后再以某种投影方式成像于屏幕上，如下图所示：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3944e39f98b24e848fd026526249c800~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-1.png" loading="lazy" class="medium-zoom-image"></p>\n<p><code>O</code> 为物体坐标系，<code>W</code> 为世界坐标系，<code>C</code> 为相机坐标系，<code>S</code> 为屏幕坐标系；以相机的视角重新描述场景相当于把场景从世界坐标系变换到相机坐标系，这个变换矩阵称之为<code>视图矩阵</code>；最后相机会把它观察到的场景投影到屏幕上，相当于进行一次投影变换，这个变换矩阵称之为<code>投影矩阵</code>。</p>\n<h4 data-id="heading-29">视图矩阵</h4>\n<p>相机坐标系中的三个轴如示例图所示分别为相机 Y 轴（上方向）、相机 Z 轴（相机视线反方向）以及相机 X 轴（右方向）；在初始化相机时我们设置了相机的位置 <code>P</code>（p1，p2，p3）、相机的焦点 <code>Q</code> （q1，q2，q3）以及相机的上方向向量 <code>U</code> （ux，uy，uz）；</p>\n<p>根据上述条件可得相机 Z 轴（相机视线反方向）单位向量 <code>F</code>（fx，fy，fz）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/199365b8f9134e8695fd0e724f84f9b7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-2.png" loading="lazy" class="medium-zoom-image"></p>\n<p>再已知相机 Y 轴向量，而 Z 轴和 Y 轴的叉乘向量即为 X 轴向量 <code>S</code>（sx，sy，sz）：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/784bbfa1940f4da180df127a6846096d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-3.png" loading="lazy" class="medium-zoom-image"></p>\n<p>视图矩阵会把场景从世界坐标系变换到相机坐标系；而在相机坐标系中，相机位置在坐标系原点 O（0，0，0），其 Y 轴单位向量为（0，1，0），Z 轴单位向量为（0，0，1），X 轴单位向量为（1，0，0）；也就是说经过视图矩阵变换之后 U 向量变为 Y 向量，F 向量变为 Z 向量，S 向量变为 X 向量，P 点移动到 O 点；如下图所示：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8bfed881fe4351a043642e7ca69b2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-18.png" loading="lazy" class="medium-zoom-image"></p>\n<p>那么视图矩阵可以拆分为<code>先平移再旋转</code>的混合变换；P 点移动到 O 点，平移矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b187e203f5a417599762a634ab0b4fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-6.png" loading="lazy" class="medium-zoom-image"></p>\n<p>接着进行旋转变换，让 U 向量变为 Y 向量，F 向量变为 Z 向量，S 向量变为 X 向量；可以先求该旋转变换的逆变换，即 Y 向量变为 U 向量，Z 向量变为 F 向量，X 向量变为 S 向量，基向量变换矩阵由变换后的基向量组合而成：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d47c1527719048e3b94233b0f732b3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-4.png" loading="lazy" class="medium-zoom-image"></p>\n<p>由于旋转矩阵为正交矩阵，其逆矩阵等于其转置矩阵；根据转置矩阵的规律，可得：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f92565cf3984ec49c6b3fe49eeba318~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-5.png" loading="lazy" class="medium-zoom-image"></p>\n<p>最终求得视图矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a0e409a539c4af5a13b64eab6f10ad0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-19.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-30">投影矩阵</h4>\n<p>投影矩阵则会把相机坐标系中的场景转换到投影平面上，以透视投影为例：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f03c32c98536457e8e0fdb16b7b907f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-7.jpg" loading="lazy" class="medium-zoom-image"></p>\n<p>透视投影相机的相关参数共同决定相机的可视区域，也被称为<code>视锥体</code>；只有在视锥体内的场景才能被相机观察到从而显示在投影平面上，其它部分在投影变换时会被裁剪掉；但是在视锥体中进行裁剪并非那么容易的事情，需要转换到一个<code>规则观察体</code>中进行：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1faa3922bda64aeb83e59c582845dd38~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-8.png" loading="lazy" class="medium-zoom-image"></p>\n<p>如上图所示规则观察体是一个正方体，其 x、y、z 的范围均为 [-1,1]。</p>\n<p>把视锥体转换为规则观察体首先需要以视锥体中轴线为中心向内压缩其远平面至完全和近平面大小相同<code>且远平面 Z 轴位置不变</code>，如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91243f3f0b84b698d065106e8ef2814~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-20.png" loading="lazy" class="medium-zoom-image"></p>\n<p>因为 3D 空间变换较为复杂，根据惯例降维处理，先从某个切面来观察；从 XZ 切面来看，对于视锥体远平面上的某点 P（xp，yp，zp），当视锥体向内压缩后会移动到 N 点位置：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b898048ff339428fbd4b151aaca0aecb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-9.png" loading="lazy" class="medium-zoom-image"></p>\n<p>根据相似三角形的性质：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/311f6d732fbd4bee8e917646d4eb9615~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-10.png" loading="lazy" class="medium-zoom-image"></p>\n<p>同理可得：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a2c950152af4779a2fb32f8f78a30e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-11.png" loading="lazy" class="medium-zoom-image"></p>\n<p>在上述例子中 P 点在<code>恰好</code>在远平面上，根据向内压缩保证远平面 Z 轴位置不变，那么 N 点也在远平面上，显而易见 <code>zn = zp</code>；但是对于视锥体中任意点，经过向内压缩，我们并不能保证它们具有和远平面点 Z 轴不变一样的性质；因此把上述规律扩展到视锥体内任意一点 P，其向内压缩之后的新位置 N 点坐标如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59b8f3d0d0314565be628ba6acf02e9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-12.png" loading="lazy" class="medium-zoom-image"></p>\n<p>转换为齐次坐标：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5019ba1bb26e4ffdba543f0d1c7012e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-13.png" loading="lazy" class="medium-zoom-image"></p>\n<p>倒推出该向内压缩矩阵 Mc 为：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e10adea3eb894db7925ef8318d47863b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-14.png" loading="lazy" class="medium-zoom-image"></p>\n<p>另外视锥体中远平面和近平面上的点经过向内压缩后 Z 轴不变，也就是说：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0c71430a82409e9475c73346dbe533~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-15.png" loading="lazy" class="medium-zoom-image"></p>\n<p>最终求出视锥体以中轴线为中心向内压缩变换矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfa0f2f459e499eb7d41dbb6de033b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-16.png" loading="lazy" class="medium-zoom-image"></p>\n<p>把视锥体以中轴线为中心向内压缩之后得到一个立方体，接着把该立方体的中心移动到坐标系原点：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b61aa822ce75458ab052c0b29253102d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-17.png" loading="lazy" class="medium-zoom-image"></p>\n<p>已知近平面和远平面距离，即可求出立方体中心点坐标 <code>C（0，0，-far/2-near/2）</code>，其移动到坐标系原点的平移矩阵 Mt 如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5ed3c10a8734526af7d99cfba5fb9f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-21.png" loading="lazy" class="medium-zoom-image"></p>\n<p>最后还需要把平移到坐标系原点的立方体进行缩放，从而让其 x、y、z 范围为 [-1,1]：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51b9db490d6f4fb3af6ecef518a2a922~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-22.png" loading="lazy" class="medium-zoom-image"></p>\n<p>近平面宽为 <code>w</code>，高为 <code>h</code>，水平宽度等于远平面距离减近平面距离 <code>far-near</code>，那么缩放矩阵 Ms 如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fb23cbb540d4d3eaebb046bb0ecab57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-23.png" loading="lazy" class="medium-zoom-image"></p>\n<p>把视锥体转换为规则观察体，变换后场景中的物体丢弃 Z 轴坐标即是其在投影面上的坐标；因此最终投影变换矩阵 <code>Mp = Mc * Mt * Ms</code>：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d1e5c7c27d3487a912d07e235624a59~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-24.png" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-31">视口变换矩阵</h4>\n<p>计算得到物体在投影面上的坐标之后，还需要进行最后一步操作，把投影面坐标转换为屏幕坐标，也被称为<code>视口变换</code>：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050b16b5b91743709f0e7ddea5be6bd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-25.png" loading="lazy" class="medium-zoom-image"></p>\n<p>图中右侧为屏幕坐标系，以屏幕左下角为原点，X 轴水平向右，Y 轴垂直向上；假设屏幕宽度为 <code>width</code>，高度为 <code>height</code>，从投影面坐标转换为屏幕坐标系，需要先进行缩放，然后再平移即可，变换矩阵如下：</p>\n<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3235af2ab6594f30877b540c1313f272~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图 3.1.3-26.png" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-32">总结</h2>\n<p>这些概念需要了解清楚，因为会陆续出现在后续的章节中并用于一些问题的解决，比如：向量点乘计算向量夹角被用于漫反射入射光颜色计算、逆转置矩阵被用于法向量变换矩阵计算等。</p></div>',
  },
  {
    name: "3\nWebGL基础\n学习时长: 49分49秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">WebGL基础</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到脱离 ThreeJS 框架直接使用 WebGL 技术构建 3D 场景，同时还会涉及到的一些 3D 图形学的基础概念；</p>\n<p>另外这一章的例子和上一章例子的效果基本相同，主要是为了通过<code>对比相同效果不同方式的实现</code>，从而更好的了解 ThreeJS 框架，知道它所封装的技术细节，从而避免在学习和使用的过程中出现效果出来了，但是不知道为什么的情况；</p>\n<p><code>WebGL 相关内容较多，没办法在短短的一章中面面俱到，后续会涉及到一些 WebGL 的 API，对于初学者来说没必要了解的很详细，知道其大概作用就好了</code>；如果有兴趣想要了解的更多可以去看看《WebGL编程指南》这本书。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/16697bc5841c5caf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-2">概述</h2>\n<p><code>WebGL</code>是一种 3D 绘图协议，这种绘图技术标准结合了<code>JavaScript</code>和<code>OpenGL ES 2.0</code>，在<code>HTML5</code>的<code>Canvas</code>元素中使用，从而可以在 Web 浏览器中呈现 3D 场景，无需使用其它插件。</p>\n<p>直接使用<code>WebGL</code>编程稍微有点复杂，特别是对于那些很少接触<code>OpenGL</code>的 Web 开发人员；因此出现了很多 WebGL 开源框架，ThreeJS 是其中比较优秀的一个。</p>\n<p>根据多次从入门到放弃的经验来看，单独学习 ThreeJS 容易给人造成不知其然的感觉，而单独学习 WebGL 又太枯燥，比较好的办法是把二者结合起来，前边的章节简单介绍了 <code>ThreeJS 基础</code>，那么这章就准备讲讲 <code>WebGL 基础</code>。</p>\n<p>为了更好的对比学习，这章用相同的程序结构实现和上一章相同的例子；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n    <span class="hljs-title function_">createWorld</span>();\n}\n\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorld</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">var</span> gl = <span class="hljs-title function_">initRender</span>();<span class="hljs-comment">//创建渲染器</span>\n    <span class="hljs-keyword">var</span> shaderProgram = <span class="hljs-title function_">initShaders</span>(gl);<span class="hljs-comment">//初始化着色器程序</span>\n    <span class="hljs-keyword">var</span> cameraMatrix = <span class="hljs-title function_">initCamera</span>();<span class="hljs-comment">//创建相机</span>\n    <span class="hljs-title function_">initLight</span>(gl,shaderProgram);<span class="hljs-comment">//创建光源</span>\n    <span class="hljs-keyword">var</span> num = <span class="hljs-title function_">initObject</span>(gl,shaderProgram);<span class="hljs-comment">//创建物体</span>\n    <span class="hljs-title function_">render</span>(gl,num,shaderProgram,cameraMatrix);<span class="hljs-comment">//渲染</span>\n}\n</code></pre>\n<p>WebGL 基础例子链接为<a href="https://link.juejin.cn?target=https%3A%2F%2Fnewbieyoung.github.io%2FThreejs_rubik%2Flesson%2Fdemo1.html" target="_blank" rel="nofollow noopener noreferrer" title="https://newbieyoung.github.io/Threejs_rubik/lesson/demo1.html" ref="nofollow noopener noreferrer">newbieyoung.github.io/Threejs_rub…</a>；</p>\n<p>最终效果如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/16699a6cd79de15b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">创建渲染器</h2>\n<p>浏览器通过<code>Canvas</code>元素支持<code>WebGL</code>，因此页面中需要一个 Canvas 元素；</p>\n<pre><code class="hljs language-HTML" lang="HTML"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"retina"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:100%;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>\n</code></pre>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> * <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;<span class="hljs-comment">//实际尺寸为显示尺寸乘以设备像素比</span>\n<span class="hljs-keyword">var</span> height = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">initRender</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">\'#retina\'</span>);\n    canvas.<span class="hljs-property">width</span> = width;\n    canvas.<span class="hljs-property">height</span> = height;\n    <span class="hljs-keyword">var</span> gl = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">\'webgl\'</span>);<span class="hljs-comment">//获取webgl上下文</span>\n    gl.<span class="hljs-title function_">clearColor</span>(<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1.0</span>);<span class="hljs-comment">//设置背景颜色</span>\n    gl.<span class="hljs-title function_">enable</span>(gl.<span class="hljs-property">DEPTH_TEST</span>);<span class="hljs-comment">//开启隐藏面消除</span>\n    <span class="hljs-keyword">return</span> gl;\n}\n</code></pre>\n<p>使用 Canvas 元素绘制图形时，需要通过<code>getContext</code>获取<code>上下文对象</code>，传入的参数不一样获取的上下文对象也不一样，比如传入参数<code>2d</code>返回的是 2D 绘图的上下文对象；要获取 WebGL 的绘图上下文对象，需要传入<code>webgl</code>；</p>\n<p>给 Canvas 元素的<code>width</code>和<code>height</code>属性赋值设置渲染器宽度和高度（ Canvas 元素的尺寸为显示尺寸乘以设备像素比），以及调用<code>clearColor</code>方法设置背景颜色这两个逻辑均可以在 ThreeJS 基础例子中找到；</p>\n<p>但是调用<code>gl.enable(gl.DEPTH_TEST)</code>开启隐藏面消除这个逻辑在 ThreeJS 基础例子则没有，这就属于 ThreeJS 框架所隐藏的 WebGL 的技术细节。</p>\n<p>在人眼看到的实际场景中的物体可能会出现相互遮挡的情况，在计算机中绘制时也要处理这种情况，为了解决这个问题，WebGL 提供了<code>隐藏面消除</code>功能，启动这个功能后 WebGL 会自动帮助我们消除那些被遮挡的物体表面；</p>\n<p>其原理在于 WebGL 绘制图形之前，会根据<code>深度缓冲区</code>的数据进行一次<code>深度检测</code>，始终只绘制层级最高的<code>片元</code>。</p>\n<p>好了！解释完一个概念，多了三个新概念！</p>\n<p><code>片元</code>可以简单理解为像素点，也就是下图中的小方块；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669ae0b2d189b04~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在构建 3D 物体时通过顶点组成<code>三角形网格</code>，但这些三角形网格都是矢量图形，最终在屏幕上显示时还是需要转化为像素图形，这种转化过程被称为<code>光栅化</code>，是计算机图形学的关键技术之一。</p>\n<p>在 CSS 中有<code>z-index</code>属性用来决定元素的层级顺序，层级高显示在上边，层级低的显示在下边；在 WebGL 同样也是通过类似的属性来决定显示顺序的，只不过因为物体位置的复杂性（多个物体混在一起时可能出现相互遮挡一部分的情况），因此渲染时每个片元都需要有一个层级数据，存储所有片元层级数据的内存空间，就被称为<code>深度缓冲区</code>。</p>\n<p>绘制片元时如果其层级数据高于深度缓冲区的层级数据则绘制出来，并更新深度缓冲区的层级数据，反之则放弃该片元，这个过程就被称为<code>深度检测</code>。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669a1f4f1db644b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>另外还有注意的一点是<code>颜色分量</code>的取值，在平时前端开发中我们一般使用的<code>RGBA颜色分量取值范围</code>是从<code>0</code>到<code>255</code>，但是由于 WebGL 继承自 OpenGL，所以它遵循传统 OpenGL 颜色分量的取值范围，即从<code>0.0</code>到<code>1.0</code>。</p>\n<h2 data-id="heading-4">初始化着色器程序</h2>\n<p>这一步骤在 ThreeJS 基础例子中也没有，同样属于 ThreeJS 框架所隐藏的 WebGL 的技术细节。</p>\n<p>WebGL 程序和普通的 JavaScript 程序不一样，WebGL 程序除了 JavaScript 部分之外，还包含两个着色器程序，分别是<code>顶点着色器</code>和<code>片元着色器</code>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669a23228ea9874~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在 ThreeJS 基础中曾提到过描述一个 3D 物体，需要<code>轮廓</code>、<code>材质</code>和<code>纹理</code>三个要素；那么可以简单的理解为<code>顶点着色器是用来处理物体轮廓的程序，片元着色器是用来处理物体材质和纹理的程序</code>。</p>\n<h3 data-id="heading-5">顶点着色器</h3>\n<pre><code class="hljs language-glsl" lang="glsl">attribute vec4 a_Position;//顶点\nattribute vec4 a_Color;//颜色\nattribute vec4 a_Normal;//法向量\n\nuniform mat4 u_MvpMatrix;//投影矩阵\nuniform mat4 u_NormalMatrix;//法向量变换矩阵\nuniform mat4 u_ModelMatrix;//模型矩阵\n\nvarying vec3 v_Position;\nvarying vec4 v_Color;\nvarying vec3 v_Normal;\nvoid main() {\n    gl_Position = u_MvpMatrix * a_Position;\n    v_Position = vec3(u_ModelMatrix * a_Position);\n    v_Color = a_Color;\n    v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));\n}\n</code></pre>\n<p>这段程序使用的是类似于<code>C语言</code>的着色器语言<code>GLSLES</code>来编写的，要看懂其实不难；</p>\n<p>了解一段程序首先得了解其输入、输出，再然后才是内部逻辑；</p>\n<ul>\n<li>输入</li>\n</ul>\n<p>顶点着色器会接收从 JavaScript 程序中传过来的数据，也就是代码片段中的<code>attribute</code>和<code>uniform</code>变量；</p>\n<p>attribute、uniform 和 varying 都是<code>存储限定符</code>，都可以用来修饰变量；</p>\n<p>attribute 变量只能用于顶点着色器；uniform 变量既可以用于顶点着色器，也可以用于片元着色器，用来表示不变的数据；（ uniform 表示不变的数据的意思是在 GLSL 程序内部不能再被改变，但是可以再次由 JavaScript 程序赋予新的值）。</p>\n<p><code>vec4</code>类似于 ThreeJS 框架中的<code>Vector4</code>对象，表示四维向量，<code>mat4</code>类似于 ThreeJS 框架中的<code>Matrix4</code>对象，表示四阶矩阵。</p>\n<ul>\n<li>输出</li>\n</ul>\n<p><code>varying</code>变量意味着该变量会从顶点着色器传入到片元着色器，这些变量也就是顶点着色器的输出了；<code>vec3</code>则类似于 ThreeJS 框架中的<code>Vector3</code>对象，表示三维向量。</p>\n<ul>\n<li>逻辑</li>\n</ul>\n<p><code>gl_Position = u_MvpMatrix * a_Position</code>投影矩阵乘以顶点坐标可以把三维空间中的物体投影到二维平面；</p>\n<p><code>v_Position = vec3(u_ModelMatrix * a_Position)</code>模型矩阵也就是物体的变换矩阵乘以顶点坐标可以获得物体经过某种变换之后新的顶点坐标；</p>\n<p><code>v_Color = a_Color</code>颜色向量不作处理直接赋值；</p>\n<p><code>v_Normal = normalize(vec3(u_NormalMatrix * a_Normal))</code>法向量变换矩阵乘以物体表面法向量可以得到物体经过某种变换之后新的面的法向量。</p>\n<p>综上所述这段顶点着色器接收从 JavaScript 程序中传入的<code>顶点</code>、<code>颜色</code>、<code>法向量</code>以及一些<code>变换矩阵</code>，然后计算变换之后的新的<code>顶点</code>、<code>颜色</code>和<code>法向量</code>数据，并将其传输给片元着色器。</p>\n<h3 data-id="heading-6">片元着色器</h3>\n<pre><code class="hljs language-glsl" lang="glsl">precision mediump float;\nuniform vec3 u_LightColor;\nuniform vec3 u_LightPosition;\nuniform vec3 u_AmbientLight;\n\nvarying vec3 v_Position;//变换后的顶点坐标\nvarying vec4 v_Color;\nvarying vec3 v_Normal;//变换后的法向量\nvoid main() {\n    vec3 normal = normalize(v_Normal);\n    vec3 lightDirection = normalize(u_LightPosition - v_Position);\n    float nDotL = max(dot(lightDirection,normal),0.0);//如果反射角大于90度，则该光线无法照射到该片元。\n    vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;\n    vec3 ambient = u_AmbientLight * v_Color.rgb;\n    gl_FragColor = vec4(diffuse + ambient, v_Color.a);\n}\n</code></pre>\n<p>还是按照输入、输出、逻辑的相关顺序来了解这段程序；</p>\n<ul>\n<li>输入</li>\n</ul>\n<p>片元着色器的输入分为两部分，第一部分是从 JavaScript 程序中传入的变量，包括<code>u_LightColor</code>点光源颜色向量、<code>u_LightPosition</code>点光源位置向量、<code>u_AmbientLight</code>环境光颜色向量；第二部分则是从顶点着色器传入的<code>v_Position</code>变换后的顶点坐标、<code>v_Color</code>顶点颜色、<code>v_Normal</code>变换后的法向量；</p>\n<ul>\n<li>输出</li>\n</ul>\n<p>可以简单理解为片元着色器的输出只有当前片元的颜色，也就是<code>gl_FragColor</code>；</p>\n<ul>\n<li>逻辑</li>\n</ul>\n<p>在具体阐述之前我们得了解几个公式：</p>\n<p><code>surfaceColor</code> = <code>emissive</code> + <code>ambient</code>+ <code>diffuse</code>+ <code>specular</code>；</p>\n<p>简单来说就是物体表面的颜色是<code>漫反射光</code>（ diffuse ）、<code>环境光</code>（ ambient ）、<code>自发光</code>（ emissive ）和<code>镜面反射光</code>（ specular ）等光照作用的总和。</p>\n<p>示例中没有考虑自发光和镜面反射，因此物体表面颜色只需要考虑漫反射和环境光的共同作用，这也就不难理解<code>gl_FragColor = vec4(diffuse + ambient, v_Color.a)</code>这句代码了。</p>\n<p>漫反射是指粗糙的物体表面反射光以不固定的角度反射出去，因此漫反射的反射光在各个方向是均匀的；</p>\n<p><code>漫反射光颜色</code> = <code>入射光颜色</code> * <code>表面颜色</code> * <code>入射角余弦</code>；</p>\n<p>根据漫反射光颜色计算公式可得<code>vec3 diffuse = u_LightColor * v_Color.rgb * nDotL</code>；</p>\n<p><code>nDotL</code>表示入射角余弦，可由<code>入射光向量</code>和<code>照射平面的法向量</code>点乘得到，对应代码中的<code>float nDotL = max(dot(lightDirection,normal),0.0)</code>；</p>\n<p>知道点光源位置以及当前片元位置，也就不难求出入射光向量了，比如<code>vec3 lightDirection = normalize(u_LightPosition - v_Position)</code>。</p>\n<p>综上所述这段片元着色器主要是接收变换后的物体轮廓和颜色信息以及设定的光源信息，依据一系列模拟现实光照的规则，计算出最终的片元颜色。</p>\n<h2 data-id="heading-7">编译着色器程序</h2>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669a997c7a03642~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在示例中顶点着色器和片元着色器，虽然是以<code>script</code>标签的形式嵌入在页面中，但是其实是以普通文本形式存在的，需要对其进行编译才能被执行；</p>\n<p>编译过程需要依赖<code>WebGL</code>上下文，具体代码可以去查看示例中的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Fblob%2Fmaster%2Flib%2Fcompile.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/blob/master/lib/compile.js" ref="nofollow noopener noreferrer">compile.js</a> 文件，基本流程如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/13/1670c18d18d23bd3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-8">创建相机</h2>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initCamera</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">var</span> viewMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix4</span>();<span class="hljs-comment">//视图矩阵</span>\n    viewMatrix.<span class="hljs-title function_">setLookAt</span>(<span class="hljs-title class_">EyePoint</span>.<span class="hljs-property">x</span>,<span class="hljs-title class_">EyePoint</span>.<span class="hljs-property">y</span>,<span class="hljs-title class_">EyePoint</span>.<span class="hljs-property">z</span>,<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n\n    <span class="hljs-keyword">var</span> projMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix4</span>();<span class="hljs-comment">//透视投影矩阵</span>\n    projMatrix.<span class="hljs-title function_">setPerspective</span>(<span class="hljs-title class_">PerspParams</span>.<span class="hljs-property">fovy</span>, width/height, <span class="hljs-title class_">PerspParams</span>.<span class="hljs-property">g_near</span>, <span class="hljs-title class_">PerspParams</span>.<span class="hljs-property">g_far</span>);\n\n    <span class="hljs-keyword">var</span> cameraMatrix = projMatrix.<span class="hljs-title function_">multiply</span>(viewMatrix);\n    <span class="hljs-keyword">return</span> cameraMatrix;\n}\n</code></pre>\n<p>相机主要的作用是投影，把三维场景投影到二维屏幕，可以用一个矩阵来表示；这个矩阵和相机的位置、焦点以及其投影方式相关，分别对应代码中的<code>viewMatrix</code>和<code>projMatrix</code>矩阵；</p>\n<p>具体的计算方式就不详细说明了，示例中使用的是第三方类库，其中封装了矩阵、向量等对象以及相关的常用方法，具体代码可以去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Fblob%2Fmaster%2Flib%2Fmatrix4.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/blob/master/lib/matrix4.js" ref="nofollow noopener noreferrer">matrix4.js</a> 文件中查看。</p>\n<h2 data-id="heading-9">创建光源</h2>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLight</span>(<span class="hljs-params">gl,shaderProgram</span>){\n    <span class="hljs-comment">//点光源</span>\n    <span class="hljs-keyword">var</span> u_LightColor = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_LightColor\'</span>);\n    gl.<span class="hljs-title function_">uniform3f</span>(u_LightColor, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);\n    <span class="hljs-keyword">var</span> u_LightPosition = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_LightPosition\'</span>);\n    gl.<span class="hljs-title function_">uniform3f</span>(u_LightPosition, <span class="hljs-number">2.5</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">3.5</span>);\n    <span class="hljs-comment">//环境光</span>\n    <span class="hljs-keyword">var</span> u_AmbientLight = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_AmbientLight\'</span>);\n    gl.<span class="hljs-title function_">uniform3f</span>(u_AmbientLight, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>);\n}\n</code></pre>\n<p>示例中只考虑了点光源和环境光，在 JavaScript 程序中设定相关参数并传输给着色器即可；</p>\n<p>在 JavaScript 程序中给<code>uniform</code>变量赋值需要用到两个方法，先通过<code>getUniformLocation</code>获取着色器中的变量，然后通过<code>uniform3f</code>给其赋值即可。</p>\n<p>比如设置光源颜色<code>u_LightColor</code>：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> u_LightColor = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_LightColor\'</span>);\ngl.<span class="hljs-title function_">uniform3f</span>(u_LightColor, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);\n</code></pre>\n<h2 data-id="heading-10">创建物体</h2>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initObject</span>(<span class="hljs-params">gl,shaderProgram</span>){\n\n    <span class="hljs-comment">//    v6----- v5</span>\n    <span class="hljs-comment">//   /|      /|</span>\n    <span class="hljs-comment">//  v1------v0|</span>\n    <span class="hljs-comment">//  | |     | |</span>\n    <span class="hljs-comment">//  | |v7---|-|v4</span>\n    <span class="hljs-comment">//  |/      |/</span>\n    <span class="hljs-comment">//  v2------v3</span>\n\n    <span class="hljs-comment">//顶点</span>\n    <span class="hljs-keyword">var</span> vertices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>([\n        <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-comment">// v0-v1-v2-v3 front</span>\n        <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-comment">// v0-v3-v4-v5 right</span>\n        <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-comment">// v0-v5-v6-v1 up</span>\n        -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-comment">// v1-v6-v7-v2 left</span>\n        -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-comment">// v7-v4-v3-v2 down</span>\n        <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,  -<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>,   <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>,-<span class="hljs-number">2.0</span>  <span class="hljs-comment">// v4-v7-v6-v5 back</span>\n    ]);\n\n    <span class="hljs-comment">//颜色</span>\n    <span class="hljs-keyword">var</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>([\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,     <span class="hljs-comment">// v0-v1-v2-v3 front</span>\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,     <span class="hljs-comment">// v0-v3-v4-v5 right</span>\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,     <span class="hljs-comment">// v0-v5-v6-v1 up</span>\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,     <span class="hljs-comment">// v1-v6-v7-v2 left</span>\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,     <span class="hljs-comment">// v7-v4-v3-v2 down</span>\n        <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-comment">// v4-v7-v6-v5 back</span>\n    ]);\n\n    <span class="hljs-comment">//法向量</span>\n    <span class="hljs-keyword">var</span> normals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>([\n        <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>,  <span class="hljs-comment">// v0-v1-v2-v3 front</span>\n        <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  <span class="hljs-comment">// v0-v3-v4-v5 right</span>\n        <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,  <span class="hljs-comment">// v0-v5-v6-v1 up</span>\n        -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,  <span class="hljs-comment">// v1-v6-v7-v2 left</span>\n        <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,   <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,  <span class="hljs-comment">// v7-v4-v3-v2 down</span>\n        <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>,   <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,-<span class="hljs-number">1.0</span>   <span class="hljs-comment">// v4-v7-v6-v5 back</span>\n    ]);\n\n    <span class="hljs-comment">//索引</span>\n    <span class="hljs-keyword">var</span> indices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([\n        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,   <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,    <span class="hljs-comment">// front</span>\n        <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,   <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>,    <span class="hljs-comment">// right</span>\n        <span class="hljs-number">8</span>, <span class="hljs-number">9</span>,<span class="hljs-number">10</span>,   <span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,    <span class="hljs-comment">// up</span>\n        <span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,  <span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,   <span class="hljs-comment">// left</span>\n        <span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,  <span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,   <span class="hljs-comment">// down</span>\n        <span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,  <span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>    <span class="hljs-comment">// back</span>\n    ]);\n\n    <span class="hljs-keyword">var</span> num = indices.<span class="hljs-property">length</span>;\n    \n    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">_initElementBuffer</span>(gl,indices)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//创建索引缓冲区</span>\n    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">_initArrayBuffer</span>(gl,shaderProgram,<span class="hljs-string">\'a_Normal\'</span>,normals,<span class="hljs-number">3</span>,gl.<span class="hljs-property">FLOAT</span>)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//创建法向量缓冲区</span>\n    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">_initArrayBuffer</span>(gl,shaderProgram,<span class="hljs-string">\'a_Position\'</span>,vertices,<span class="hljs-number">3</span>,gl.<span class="hljs-property">FLOAT</span>)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//创建顶点缓冲区</span>\n    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_">_initArrayBuffer</span>(gl,shaderProgram,<span class="hljs-string">\'a_Color\'</span>,colors,<span class="hljs-number">3</span>,gl.<span class="hljs-property">FLOAT</span>)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">////创建颜色缓冲区</span>\n\n    <span class="hljs-keyword">return</span> num;\n}\n</code></pre>\n<p>在 ThreeJS 框架中创建一个正方体只需要创建一个<code>BoxGeometry</code>对象就好了，脱离框架之后我们需要准备<code>顶点</code>、<code>颜色</code>、<code>法向量</code>以及<code>索引</code>等数据；</p>\n<p>前三个很好理解，这里只简单解释下<code>索引</code>，其实就是顶点序号集合，每三个顶点序号可以组成一个<code>三角形网格</code>；</p>\n<p>以代码中的索引数组为例，第一行<code>0, 1, 2,</code>表示编号为 0、1、2 的三个顶点组成一个三角形网格，接着的<code>0, 2, 3,</code>表示编号为 0、2、3 的三个顶点组成一个另一个三角形网格，这两个三角形网格刚好就构成了正方体的正面。</p>\n<blockquote>\n<p>注释中<code>v0</code>、<code>v1</code>、<code>v2</code>、<code>v3</code>、<code>v4</code>、<code>v5</code>、<code>v6</code>、<code>v7</code>表示顶点，数字为其编号；<code>front</code>、<code>right</code>、<code>up</code>、<code>left</code>、<code>down</code>、<code>back</code>分别表示正方体的<code>前</code>、<code>右</code>、<code>上</code>、<code>左</code>、<code>下</code>、<code>后</code>面。</p>\n</blockquote>\n<p>准备好这些数据之后，需要传输给顶点着色器，具体代码封装在<code>_initArrayBuffer</code>方法中；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//初始化数据缓冲区</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">_initArrayBuffer</span> (gl,shaderProgram,attribute, data, num, type) {\n    <span class="hljs-comment">//创建缓冲区</span>\n    <span class="hljs-keyword">var</span> buffer = gl.<span class="hljs-title function_">createBuffer</span>();\n    <span class="hljs-keyword">if</span> (!buffer) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'Failed to create the buffer object!\'</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-comment">//将缓冲区对象绑定到目标</span>\n    gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, buffer);\n    gl.<span class="hljs-title function_">bufferData</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, data, gl.<span class="hljs-property">STATIC_DRAW</span>);\n    <span class="hljs-comment">//把缓冲区数据赋予指定变量</span>\n    <span class="hljs-keyword">var</span> a_attribute = gl.<span class="hljs-title function_">getAttribLocation</span>(shaderProgram, attribute);\n    <span class="hljs-keyword">if</span> (a_attribute &lt; <span class="hljs-number">0</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'Failed to get the storage location of \'</span> + attribute);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    gl.<span class="hljs-title function_">vertexAttribPointer</span>(a_attribute, num, type, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    gl.<span class="hljs-title function_">enableVertexAttribArray</span>(a_attribute);\n    <span class="hljs-comment">//解绑缓冲区</span>\n    gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, <span class="hljs-literal">null</span>);\n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n}\n</code></pre>\n<ol>\n<li>首先调用<code>gl.createBuffer</code>创建<code>数据缓冲区</code>，可以简单理解为一块内存空间；</li>\n<li>然后调用<code>gl.bindBuffer</code>、<code>gl.bufferData</code>把数据绑定到创建的缓冲区；</li>\n<li>接着调用<code>gl.getAttribLocation</code>获取着色器变量；</li>\n<li>再然后调用<code>gl.vertexAttribPointer</code>设置数据的划分方式，因为传入的数据是浮点型数组，但是着色器中接收的变量类型要么是向量要么是矩阵，自然需要在传入数据的时候确定其划分方式（比如在每三个一组解释索引数据时，其实就是按照设定的划分方式解释的）；</li>\n<li>最后调用<code>gl.enableVertexAttribArray</code>激活。</li>\n</ol>\n<h2 data-id="heading-11">渲染</h2>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> rotateAngle = <span class="hljs-number">0</span>;\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">gl,num,shaderProgram,cameraMatrix</span>){\n    <span class="hljs-comment">//模型矩阵</span>\n    rotateAngle += <span class="hljs-number">.3</span>;\n    <span class="hljs-keyword">var</span> modelMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix4</span>();\n    modelMatrix.<span class="hljs-title function_">rotate</span>(rotateAngle, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    modelMatrix.<span class="hljs-title function_">rotate</span>(rotateAngle, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> u_ModelMatrix = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_ModelMatrix\'</span>);\n    gl.<span class="hljs-title function_">uniformMatrix4fv</span>(u_ModelMatrix, <span class="hljs-literal">false</span>, modelMatrix.<span class="hljs-property">elements</span>);\n\n    <span class="hljs-comment">//投影矩阵</span>\n    <span class="hljs-keyword">var</span> mvpMatrix = cameraMatrix;\n    <span class="hljs-keyword">var</span> originMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix4</span>();\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;cameraMatrix.<span class="hljs-property">elements</span>.<span class="hljs-property">length</span>;i++){\n        originMatrix.<span class="hljs-property">elements</span>[i] = cameraMatrix.<span class="hljs-property">elements</span>[i];\n    }\n    mvpMatrix.<span class="hljs-title function_">multiply</span>(modelMatrix);\n    <span class="hljs-keyword">var</span> u_MvpMatrix = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_MvpMatrix\'</span>);\n    gl.<span class="hljs-title function_">uniformMatrix4fv</span>(u_MvpMatrix, <span class="hljs-literal">false</span>, mvpMatrix.<span class="hljs-property">elements</span>);\n\n    <span class="hljs-comment">//法向量变换矩阵</span>\n    <span class="hljs-keyword">var</span> normalMatrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix4</span>(); \n    normalMatrix.<span class="hljs-title function_">setInverseOf</span>(modelMatrix);\n    normalMatrix.<span class="hljs-title function_">transpose</span>();\n    <span class="hljs-keyword">var</span> u_NormalMatrix = gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">\'u_NormalMatrix\'</span>);\n    gl.<span class="hljs-title function_">uniformMatrix4fv</span>(u_NormalMatrix, <span class="hljs-literal">false</span>, normalMatrix.<span class="hljs-property">elements</span>);\n\n    gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span> | gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>);\n    gl.<span class="hljs-title function_">drawElements</span>(gl.<span class="hljs-property">TRIANGLES</span>, num, gl.<span class="hljs-property">UNSIGNED_BYTE</span>, <span class="hljs-number">0</span>);\n\n    <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n        <span class="hljs-title function_">render</span>(gl,num,shaderProgram,originMatrix);\n    });\n}\n</code></pre>\n<p>基本逻辑和 ThreeJS 基础例子中的渲染方法类似；</p>\n<p>先处理物体的旋转<code>modelMatrix.rotate(rotateAngle, 1, 0, 0)</code>表示绕<code>X轴</code>旋转一定的角度，<code>modelMatrix.rotate(rotateAngle, 0, 1, 0)</code>则表示绕<code>Y轴</code>旋转一定的角度；</p>\n<p>投影时除了要考虑相机的影响之外，物体本身的变换也会有影响，因此相机矩阵还需要乘以物体本身的变换矩阵（模型矩阵）；</p>\n<p>另外物体的变换还会导致物体表面的法向量也发生变化，但是和顶点不一样，法向量的变换矩阵是物体变换矩阵的<code>逆转置矩阵</code>，因此需要单独计算；</p>\n<p>最后调用<code>gl.clear</code>清空上一次的渲染结果，调用<code>gl.drawElements</code>重新绘制。</p>\n<h2 data-id="heading-12">总结</h2>\n<p>上文中介绍了 WebGL 程序的基本结构，并对示例子中的<code>顶点着色器</code>和<code>片元着色器</code>进行了简单的讲解，主要内容包括：<code>GLSL 语言的基本数据类型</code>、<code>存储限定符</code>、<code>物体表面光照处理</code>、<code>漫反射光颜色计算</code>、<code>入射光向量计算</code>以及<code>着色器编译流程</code>等；</p>\n<p>同时还解释了<code>光栅化</code>、<code>隐藏面消除</code>、<code>深度缓冲区</code>、<code>深度检测</code>、<code>片元</code>等基础概念；</p>\n<p>另外还介绍了<code>如何在 JavaScript 程序中传输数据给着色器程序</code>；</p>\n<p>通过这一章的学习我们不难发现在 WebGL 程序中，JavaScript 的主要作用是编译着色器程序、准备以及传输数据，而渲染相关的工作还是由着色器程序负责的；</p>\n<p>再对比上一个例子可以清楚的看到<code>ThreeJS 框架既隐藏了 WebGL 的相关技术细节，还提供了很多方便易用的数学工具；另外还抽象出很多易于理解的概念，极大的降低了开发门槛</code>。</p></div>',
  },
  {
    name: "4\n静态魔方\n学习时长: 32分3秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">静态魔方</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>如何在微信小游戏中利用 ThreeJS 框架构建一个静态的简易三阶魔方；</li>\n<li>解决使用 ThreeJS 框架开发微信小游戏可能会遇到的一些兼容性的问题；</li>\n<li>ThreeJS 框架中<code>Texture</code>纹理对象的相关知识；</li>\n<li>ThreeJS 框架中<code>Mesh</code>网格对象的相关知识；</li>\n<li>ThreeJS 框架中<code>BoxGeometry</code>盒子几何体对象的相关知识；</li>\n<li>ThreeJS 框架中<code>视角控制器</code>的相关知识。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p>魔方是<code>1974</code>年由匈牙利的<code>鲁比克</code>教授发明，因此魔方又被称为<code>Rubik\'s Cube</code>；</p>\n<p>魔方有很多类型但其中最经典的是<code>三阶魔方</code>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc5ca1358d2e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<blockquote>\n<p>分为<code>上</code>、<code>中</code>、<code>下</code>三层，每层<code>3*3</code>个小方块，共<code>27</code>个小方块。</p>\n</blockquote>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo2" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo2" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc674d7abffc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">项目初始化</h2>\n<p>如何快速上手微信小游戏可以看看官方的文档<a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminigame%2Fdev%2F" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/minigame/dev/" ref="nofollow noopener noreferrer">快速上手</a>；</p>\n<p>按照文档中的指引看到<code>飞机大战</code>示例小游戏的时候就说明开发环境已经准备好了。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc709c0c5295~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>小游戏只有两个必要文件，其它文件都可以删掉；</p>\n<ul>\n<li><code>game.js</code>入口文件；</li>\n<li><code>game.json</code>配置文件；</li>\n</ul>\n<p>ThreeJS 框架是基于 DOM 环境设计的，因此有些 API 在微信小游戏中没有；为了兼容那些基于浏览器环境设计的游戏引擎，微信小游戏官方提供了一个名叫<code>weapp-adapter.js</code>的脚本，但是可惜的是并没有对其进行进一步的更新和维护，因此<code>可靠性较差</code>，至少对于 ThreeJS 框架而言不能通过这个脚本顺利无缝的接入小游戏；</p>\n<blockquote>\n<p>进一步了解可以查看官方文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.weixin.qq.com%2Fminigame%2Fdev%2Ftutorial%2Fbase%2Fadapter.html" target="_blank" rel="nofollow noopener noreferrer" title="https://developers.weixin.qq.com/minigame/dev/tutorial/base/adapter.html" ref="nofollow noopener noreferrer">Adapter</a></p>\n</blockquote>\n<p>不过在<code>Github</code>上有人对其进行了改良, 针对 PixiJS、<code>ThreeJS</code>、Babylon 等流行框架做了<code>适配</code>，源代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffinscn%2Fweapp-adapter" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/finscn/weapp-adapter" ref="nofollow noopener noreferrer">finscn/weapp-adapter</a>，把源代码复制下来，放入到项目的<code>adapter</code>目录中。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc7a0cfa3d72~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>然后在入口文件<code>game.js</code>中引入；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-string">\'/adapter/index.js\'</span>\n</code></pre>\n<h2 data-id="heading-4">主逻辑初始化</h2>\n<p>在<code>js</code>目录中创建<code>threejs</code>目录并把 ThreeJS 框架源文件放入其中，然后新增<code>main.js</code>脚本，用来处理小游戏的主逻辑；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc8dede3e809~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在入口文件<code>game.js</code>中引入主逻辑脚本，然后执行。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'./js/main\'</span>\n<span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>()\n</code></pre>\n<p>然后在<code>main.js</code>中继续使用<code>ThreeJS基础程序结构</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'threejs/three.js\'</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">Context</span> = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">\'webgl\'</span>);\n\n<span class="hljs-comment">/**\n * 游戏主函数\n */</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = <span class="hljs-title class_">Context</span>;<span class="hljs-comment">//绘图上下文</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">devicePixelRatio</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewCenter</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//原点</span>\n        \n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initRender</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initCamera</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initScene</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initLight</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initObject</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();\n    }\n    \n    <span class="hljs-title function_">initRender</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n    \n    <span class="hljs-title function_">initCamera</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n    \n    <span class="hljs-title function_">initScene</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n    \n    <span class="hljs-title function_">initLight</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n    \n    <span class="hljs-title function_">initObject</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n    \n    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">//...</span>\n    }\n}\n</code></pre>\n<p>这里需要注意几点：</p>\n<ul>\n<li>ThreeJS 框架源代码通过<code>import * as THREE from \'threejs/three.js\'</code>引入；</li>\n<li>在微信小游戏调用<code>wx.createCanvas()</code>接口可以创建一个 Canvas 对象，但是只有第一次调用该接口创建的 Canvas 对象中绘制的图形会显示到屏幕上，后续调用创建的都是<code>离屏Canvas</code>；由于引入的<code>adapter</code>脚本中已经调用了一次 wx.createCanvas() 而且把创建的 Canvas 对象作为全局变量暴露了出来，因此在代码中就可以直接使用了；这就解释了为什么代码明明没有定义却可以直接执行<code>const Context = canvas.getContext(\'webgl\')</code>。</li>\n<li>因为在<code>ThreeJS基础</code>那一章中详细的讲解过了，因此这里省略了<code>initRender</code>、<code>initCamera</code>、<code>initScene</code>、<code>initLight</code>、<code>initObject</code>以及<code>render</code>等方法的具体实现。</li>\n</ul>\n<h2 data-id="heading-5">构建简易魔方</h2>\n<p>出于方便计算的考虑，我们假定魔方中心在坐标系原点；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bc993200062e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>根据示例图可知只需要确定<code>魔方左上角顶点A</code>以及<code>小方块边长len</code>就可以得到所有小方块的中心点；比如如果<code>点A</code>的坐标为<code>(x,y,z)</code>那么<code>左上角小方块中心点C</code>的坐标即为<code>(x+len/2,y-len/2,z-len/2)</code>;</p>\n<p>具体代码实现过程如下：</p>\n<ol>\n<li>首先在<code>js</code>目录中创建<code>object</code>目录，把小游戏中涉及的所有对象统一放入到这个目录中；</li>\n</ol>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bca60ba337eb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ol start="2">\n<li>新建<code>Rubik.js</code>魔方对象；</li>\n<li>引入<code>ThreeJS</code>框架代码；</li>\n</ol>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第1行 */</span>\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'../threejs/three.js\'</span>\n</code></pre>\n<ol start="4">\n<li>定义<code>基础模型参数</code>；</li>\n</ol>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第4行至第14行 */</span>\n<span class="hljs-keyword">const</span> <span class="hljs-title class_">BasicParams</span> = {\n\t<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,\n\t<span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,\n\t<span class="hljs-attr">z</span>: <span class="hljs-number">0</span>,\n\t<span class="hljs-attr">num</span>: <span class="hljs-number">3</span>,\n\t<span class="hljs-attr">len</span>: <span class="hljs-number">50</span>,\n\t<span class="hljs-comment">//右、左、上、下、前、后</span>\n\t<span class="hljs-attr">colors</span>: [<span class="hljs-string">\'#ff6b02\'</span>, <span class="hljs-string">\'#dd422f\'</span>,\n\t\t<span class="hljs-string">\'#ffffff\'</span>, <span class="hljs-string">\'#fdcd02\'</span>,\n\t\t<span class="hljs-string">\'#3d81f7\'</span>, <span class="hljs-string">\'#019d53\'</span>]\n};\n</code></pre>\n<p><code>阶数</code>为<code>3</code>，<code>小方块边长</code>为<code>50</code>，<code>魔方中心</code>在坐标系<code>原点</code>，<code>colors</code>为魔方六个面的颜色数组；</p>\n<ol start="5">\n<li>生成纹理；</li>\n</ol>\n<p>在<code>ThreeJS基础</code>那一章，我们使用<code>BoxGeometry</code>对象创建过<code>纯色</code>的正方体，但是在三阶魔方中需要用黑色的间隙区分同一个面的不同小方块，因此需要用到<code>Texture</code>纹理对象；</p>\n<p>在 ThreeJS 框架中既可以通过图片创建纹理对象，也可以直接使用<code>Canvas</code>元素创建；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第61行至第78行 */</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">faces</span>(<span class="hljs-params">rgbaColor</span>) {\n\t<span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">\'canvas\'</span>);\n\tcanvas.<span class="hljs-property">width</span> = <span class="hljs-number">256</span>;\n\tcanvas.<span class="hljs-property">height</span> = <span class="hljs-number">256</span>;\n\t<span class="hljs-keyword">var</span> context = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">\'2d\'</span>);\n\t<span class="hljs-comment">//画一个宽高都是256的黑色正方形</span>\n\tcontext.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">\'rgba(0,0,0,1)\'</span>;\n\tcontext.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>);\n\t<span class="hljs-comment">//在内部用某颜色的16px宽的线再画一个宽高为224的圆角正方形并用改颜色填充</span>\n\tcontext.<span class="hljs-title function_">rect</span>(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>);\n\tcontext.<span class="hljs-property">lineJoin</span> = <span class="hljs-string">\'round\'</span>;\n\tcontext.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">16</span>;\n\tcontext.<span class="hljs-property">fillStyle</span> = rgbaColor;\n\tcontext.<span class="hljs-property">strokeStyle</span> = rgbaColor;\n\tcontext.<span class="hljs-title function_">stroke</span>();\n\tcontext.<span class="hljs-title function_">fill</span>();\n\t<span class="hljs-keyword">return</span> canvas;\n}\n</code></pre>\n<p><code>faces</code>函数接收颜色参数然后返回如下图案的 Canvas 元素；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcb3b00205d3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ol start="6">\n<li>构建简易魔方；</li>\n</ol>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第23行至第56行 */</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">SimpleCube</span>(<span class="hljs-params">x, y, z, num, len, colors</span>) {\n\t<span class="hljs-comment">//魔方左上角坐标</span>\n\t<span class="hljs-keyword">var</span> leftUpX = x - num/<span class="hljs-number">2</span>*len;\n\t<span class="hljs-keyword">var</span> leftUpY = y + num/<span class="hljs-number">2</span>*len;\n\t<span class="hljs-keyword">var</span> leftUpZ = z + num/<span class="hljs-number">2</span>*len;\n\n\t<span class="hljs-keyword">var</span> cubes = [];\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) {\n\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; num * num; j++) {\n\n\t\t\t<span class="hljs-keyword">var</span> myFaces = [];\n\t\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++) {\n\t\t\t\tmyFaces[k] = <span class="hljs-title function_">faces</span>(<span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>[k]);\n\t\t\t}\n\n\t\t\t<span class="hljs-keyword">var</span> materials = [];\n\t\t\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++) {\n\t\t\t\t<span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(myFaces[k]);\n\t\t\t\ttexture.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;\n\t\t\t\tmaterials.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>({ <span class="hljs-attr">map</span>: texture}));\n\t\t\t}\n\n\t\t\t<span class="hljs-keyword">var</span> cubegeo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(len, len, len);\n\t\t\t<span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(cubegeo, materials);\n\n\t\t\t<span class="hljs-comment">//依次计算各个小方块中心点坐标</span>\n\t\t\tcube.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = (leftUpX + len / <span class="hljs-number">2</span>) + (j % num) * len;\n\t\t\tcube.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = (leftUpY - len / <span class="hljs-number">2</span>) - <span class="hljs-built_in">parseInt</span>(j / num) * len;\n\t\t\tcube.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = (leftUpZ - len / <span class="hljs-number">2</span>) - i * len;\n\t\t\tcubes.<span class="hljs-title function_">push</span>(cube)\n\t\t}\n\t}\n\t<span class="hljs-keyword">return</span> cubes;\n}\n</code></pre>\n<p><code>SimpleCube</code>函数参数说明：</p>\n<ul>\n<li><code>x, y, z</code>表示魔方中心点；</li>\n<li><code>num</code>表示魔方阶数；</li>\n<li><code>len</code>表示小方块宽高；</li>\n<li><code>colors</code>表示魔方六个面颜色数组；</li>\n</ul>\n<p>先定义一个小方块数组<code>cubes</code>，然后在<code>i</code>、<code>j</code>两个 for 循环中创建小方块，创建小方块之前，先需要根据颜色数组<code>colors</code>生成小方块六个面的图案；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第35行 */</span>\nmyFaces[k] = <span class="hljs-title function_">faces</span>(<span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>[k]);\n</code></pre>\n<p>再然后根据 Canvas 图案生成<code>纹理</code>（把 Canvas 元素直接传入到<code>Texture</code>对象中即可）；另外<code>needsUpdate</code>属性需要设置为<code>true</code>才能保证创建纹理时 Canvas 内容已经加载完成了，如果不设置为<code>true</code>则会出现纹理一片漆黑的情况；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第40行至第41行 */</span>\n<span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(myFaces[k]);\ntexture.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;\n</code></pre>\n<p>接着根据纹理生成<code>材质</code></p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第42行 */</span>\nmaterials.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>({ <span class="hljs-attr">map</span>: texture}));\n</code></pre>\n<blockquote>\n<p>这里还是使用<code>MeshLambertMaterial</code>兰伯特材质，需要注意的是创建纯色的兰伯特材质时设置的是<code>color</code>参数：<code>new THREE.MeshLambertMaterial( {color: 0xff0000} )</code>；但是通过纹理创建时需要设置其<code>map</code>参数：<code>new THREE.MeshLambertMaterial({ map: texture})</code>。</p>\n</blockquote>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第45、46行 */</span>\n<span class="hljs-keyword">var</span> cubegeo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(len, len, len);\n<span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(cubegeo, materials);\n</code></pre>\n<p>通过<code>Mesh</code>网格对象组合<code>轮廓</code>、<code>材质</code>即可得到小方块了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第49行至51行 */</span>\ncube.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = (x + len / <span class="hljs-number">2</span>) + (j % <span class="hljs-number">3</span>) * len;\ncube.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = (y - len / <span class="hljs-number">2</span>) - <span class="hljs-built_in">parseInt</span>(j / <span class="hljs-number">3</span>) * len;\ncube.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = (z - len / <span class="hljs-number">2</span>) - i * len;\n</code></pre>\n<p>最后我们还需要根据推导的规律设置各个小方块的中心点，最终组成魔方。</p>\n<ol start="7">\n<li>定义魔方对象；</li>\n</ol>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第80行至92行 */</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rubik</span> {\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">main</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span> = main;\n    }\n    \n    <span class="hljs-title function_">model</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span> = <span class="hljs-title class_">SimpleCube</span>(<span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">x</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">y</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">z</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">num</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>);<span class="hljs-comment">//生成魔方小正方体</span>\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n          <span class="hljs-keyword">var</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i];\n          <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(item);\n        }\n    }\n}\n</code></pre>\n<h2 data-id="heading-6">显示魔方</h2>\n<p>在<code>main.js</code>中引入简易魔方对象代码<code>Rubik.js</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第3行 */</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">BasicRubik</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/Rubik.js\'</span>\n</code></pre>\n<p>然后在创建物体函数<code>initObject</code>中创建魔方；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第76行至第79行 */</span>\n<span class="hljs-title function_">initObject</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">var</span> rubik = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicRubik</span>(<span class="hljs-variable language_">this</span>);\n    rubik.<span class="hljs-title function_">model</span>();\n}\n</code></pre>\n<p>编译并执行程序会在模拟器中看到如下效果：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcc518439922~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>有人可能会纳闷了折腾这么久，就整出个这玩意吗？</p>\n<p>其实之所以会这样是因为<code>我们设置的相机的位置是在坐标系的Z轴，魔方的中心在坐标系原点，它们刚好处于同一条直线上，导致显示出来的是魔方的正面</code>。</p>\n<h2 data-id="heading-7">视角控制</h2>\n<p>为了解决只能看到魔方正面这个问题，我们需要改变视角；</p>\n<p>在 ThreeJS 框架中提供了很多视角控制对象，并有对应的例子演示：</p>\n<ul>\n<li>飞行控件<code>FlyControls</code>；</li>\n</ul>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcd160a85cb8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>该控件可以用来进行飞行模拟，用键盘和鼠标控制相机的移动和旋转，官网提供了<code>示例程序</code>，链接为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fexamples%2F%3Fq%3Dcontr%23misc_controls_fly" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/examples/?q=contr#misc_controls_fly" ref="nofollow noopener noreferrer">threejs.org/examples/?q…</a>，大致效果如图中所示，有兴趣可以去示例程序<code>体验</code>以及<code>查看用法</code>以及<code>具体实现</code>。</p>\n<ul>\n<li>第一人称控件<code>FirstPersonControls</code>；</li>\n</ul>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcda9d789802~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>喜欢玩游戏的同学对这种视角应该很熟悉，也是鼠标和键盘结合起来控制视角，示例程序链接为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fexamples%2F%3Fq%3Dcont%23misc_controls_pointerlock" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/examples/?q=cont#misc_controls_pointerlock" ref="nofollow noopener noreferrer">threejs.org/examples/?q…</a>。</p>\n<ul>\n<li>轨道空间控件<code>OrbitControls</code>；</li>\n</ul>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bce4e990770d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>这种视角类似于轨道中的卫星围绕地球转动时的观察视角，在 PC 上可以用鼠标控制相机环绕观察，在移动端则是手指触摸控制，示例程序链接为：<a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fexamples%2F%3Fq%3Dcont%23misc_controls_orbit" target="_blank" rel="nofollow noopener noreferrer" title="https://threejs.org/examples/?q=cont#misc_controls_orbit" ref="nofollow noopener noreferrer">threejs.org/examples/?q…</a>。</p>\n<p><code>OrbitControls</code>控制器刚好可以用来观察上边创建的简易三阶魔方，用法很简单：</p>\n<ol>\n<li>首先得去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmrdoob%2Fthree.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/mrdoob/three.js" ref="nofollow noopener noreferrer">ThreeJS框架的Github仓库</a> 下载该控制器的源代码，然后放入到项目中；</li>\n</ol>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcf35cc4e7f3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>红框中的<code>OrbitControls.js</code>文件即是，其它文件为其它控制器的源代码；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bcfb6b421118~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ol start="2">\n<li>然后在小游戏主逻辑脚本<code>main.js</code>中引入；</li>\n</ol>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-built_in">require</span>(<span class="hljs-string">\'threejs/OrbitControls.js\'</span>)\n</code></pre>\n<p>这时编译项目会发现有报错：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd049aae7faa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>这是因为<code>OrbitControls</code>控制器源代码中直接用<code>全局变量</code>的方式使用的 ThreeJS 框架的全局对象<code>THREE</code>，解决办法是在使用之前引入即可；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd0e2f656885~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<ol start="3">\n<li>初始化控制器</li>\n</ol>\n<p>因为控制器和相机有关，因此初始化代码放到<code>initCamera</code>方法中；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第45行至第56行 */</span>\n<span class="hljs-title function_">initCamera</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">45</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1500</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">aspect</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">up</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//正方向</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-title function_">lookAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewCenter</span>);\n    \n    <span class="hljs-comment">//轨道视角控制器</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orbitController</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">OrbitControls</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>.<span class="hljs-property">domElement</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orbitController</span>.<span class="hljs-property">enableZoom</span> = <span class="hljs-literal">false</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orbitController</span>.<span class="hljs-property">rotateSpeed</span> = <span class="hljs-number">2</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">orbitController</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewCenter</span>;<span class="hljs-comment">//设置控制点</span>\n}\n</code></pre>\n<p><code>enableZoom</code>设置为<code>false</code>表示禁止缩放，<code>rotateSpeed</code>和环绕转动的速度有关，控制点<code>target</code>表示环绕中心，因为简易三阶魔方的中心在原点因此控制器的环绕中心也设置为原点。</p>\n<p>到这一步，按道理应该都准备就绪了，但是编译执行却发现页面空白一片；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd15673ff32a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>原因在于尽管我们已经引入了<code>适配器脚本</code>但是控制器代码还是不能完全兼容微信小游戏环境，需要再进行一些修改。</p>\n<ol start="4">\n<li>控制器源代码适配</li>\n</ol>\n<p><code>OrbitControls</code>控制器每次改变相机位置时都会调用其<code>update</code>方法；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd1cfbe36c67~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>打断点调试时会发现<code>sphericalDelta</code>变量的值有问题，这个变量是用来控制相机环绕时位置的<code>经度</code>和<code>纬度</code>的，如果有问题那么会导致相机位置的更新也出问题，从而页面就空白了；</p>\n<p>在源代码中搜索<code>sphericalDelta</code>变量会发现只有一个地方会对这个变量进行赋值；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd25546504b3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>而在赋值时就已经出现了问题，接着再查<code>rotateLeft</code>方法，在<code>handleTouchMoveRotate</code>和<code>handleMouseMoveRotate</code>方法中均有调用，前者是用于处理移动端手指触摸事件，后者是用于处理 PC 端鼠标事件，在微信小游戏中只需要考虑前者；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd2d2d160785~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><code>element</code>是初始化控制器时传入的<code>Canvas</code>元素，在微信小游戏中通过<code>clientHeight</code>是没办法获取其高度的，需要改为<code>height</code>属性。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* OrbitControls.js 第614行至第616行 */</span>\n<span class="hljs-title function_">rotateLeft</span>(<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * rotateDelta.<span class="hljs-property">x</span> / element.<span class="hljs-property">height</span>);\n<span class="hljs-title function_">rotateUp</span>(<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * rotateDelta.<span class="hljs-property">y</span> / element.<span class="hljs-property">height</span>);\n</code></pre>\n<p>到此应该是没有问题了，编译运行，手指滑动屏幕就可以观察简易三阶魔方的各个面了。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673bd35078dcb95~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-8">总结</h2>\n<p>在这一章中我们学会了如何在微信小游戏中使用 ThreeJS 框架，并构建出一个静态的简易三阶魔方；</p>\n<p>另外<code>对于 ThreeJS 框架中不熟悉的知识点可以多去查看官方示例了解其作用以及使用方法；遇到问题需要调试源代码时也不需要慌，没必要了解其每一行代码，先把握整体结构然后逐步定位问题即可。</code></p></div>',
  },
  {
    name: "5\n正反视图\n学习时长: 42分52秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">正反视图</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>实现魔方微信小游戏正反视图功能；</li>\n<li>ThreeJS 框架<code>Group</code>集合对象的使用；</li>\n<li>进一步理解透视投影相机相关参数，并计算其任一裁切面的宽高；</li>\n<li>ThreeJS 框架中简单的<code>位移变换</code>，比如改变物体中心、缩放物体大小、旋转物体等；</li>\n<li>ThreeJS 框架中加载器的相关知识以及<code>TextureLoader</code>纹理加载器的使用；</li>\n<li>ThreeJS 框架中<code>PlaneGeometry</code>平面对象的使用；</li>\n<li>ThreeJS 框架中<code>MeshBasicMaterial</code>基础材质对象的使用；</li>\n<li>微信小游戏触摸事件机制在 3D 场景中应用；</li>\n<li>在 ThreeJS 框架中绘制 UI 元素并处理其事件监听。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p>所谓的<code>正反视图</code>即如下图所示：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/1672696fd2dc383f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>之所以会有这个功能，主要是因为我个人感觉，对于那些<code>空间想象能力强</code>的人来说<code>如果能同时看到六个面，那么在使用时应该是不需要再进行魔方整体转动操作了</code>；</p>\n<p>另外两个视角还能扩展为<code>智能教学视图</code>以及<code>操作视图</code>这样就可以新增<code>教学功能</code>了（当然这个功能暂时没有）；</p>\n<p>同时出于方便操作的考虑，允许滑动控制两个视图的大小。</p>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo3" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo3" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/16726aa961f10991~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">实现</h2>\n<p>对于这个功能而言需要实现三点：</p>\n<h3 data-id="heading-4">1. 场景中需要再增加一个魔方；</h3>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第78行至第92行 */</span>\n<span class="hljs-title function_">initObject</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-comment">//正视角魔方</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicRubik</span>(<span class="hljs-variable language_">this</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">model</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span>);\n\n    <span class="hljs-comment">//反视角魔方</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicRubik</span>(<span class="hljs-variable language_">this</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">model</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">endViewName</span>);\n}\n</code></pre>\n<p>在初始化物体时创建两个简易三阶魔方即可，同时赋予它们不同的名称方便区分；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第18、19行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span> = <span class="hljs-string">\'front-rubik\'</span>;<span class="hljs-comment">//正视角魔方名称</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">endViewName</span> = <span class="hljs-string">\'end-rubik\'</span>;<span class="hljs-comment">//反视角魔方名称</span>\n</code></pre>\n<h3 data-id="heading-5">2. 控制魔方所占区域大小</h3>\n<p>在场景中创建两个魔方后会发现它们重叠在一起了，究其原因在于这两个魔方<code>位置相同</code>，为了解决这个问题需要对它们进行位移变换，改变它们的<code>中心点</code>让它们处于<code>页面上部</code>和<code>页面下部</code>两个不同区域；</p>\n<p>另外还要改变它们的<code>大小</code>，防止所占区域变小时显示不全。</p>\n<p>进行位移变换时需要注意一个问题，在代码中我们所谓的<code>创建一个魔方</code>，其实只是创建了<code>27 个小方块</code>，然后让它们按某种规律排列而已；</p>\n<p>程序中并不存在<code>魔方对象</code>，因此进行位移变换时没办法对魔方对象进行<code>整体的位移变换</code>，只能遍历这 27 个小方块然后对它们分别进行位移变换，这种方式很麻烦，特别是当独立的子元素数量很多的时候。</p>\n<p>考虑到这种情况 ThreeJS 框架提供了<code>Group</code>集合对象，当一个物体由很多独立的子元素组成时，可以创建一个集合对象，然后把所有子元素加入到集合对象中；</p>\n<p>当需要对物体进行整体位移变换时只需要对集合对象进行位移变换即可。</p>\n<p>因此需要修改<code>Rubik</code>对象的<code>model()</code>方法；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第85行至第111行 */</span>\n<span class="hljs-title function_">model</span>(<span class="hljs-params">type</span>) {\n    <span class="hljs-comment">//创建魔方集合</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Group</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">childType</span> = type;\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span> = <span class="hljs-title class_">SimpleCube</span>(<span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">x</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">y</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">z</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">num</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span>, <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>);<span class="hljs-comment">//生成魔方小正方体</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n      <span class="hljs-keyword">var</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i];\n\n      <span class="hljs-comment">/**\n       * 小方块不再直接加入场景了；\n       * 而是先加入魔方集合，然后再把魔方集合加入场景。\n       */</span>\n      <span class="hljs-comment">//this.main.scene.add(item);</span>\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">add</span>(item);\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>);\n}\n</code></pre>\n<p><code>new THREE.Group()</code>可以直接创建<code>Group</code>集合对象，加入子元素需要调用其<code>add</code>方法，把所有小方块放入到魔方集合中之后就只需要对<code>this.group</code>进行位移变换就可以了。</p>\n<p>当一个魔方占<code>100%</code>页面区域时，它的中心点在原点；那当这个魔方所占页面区域高度<code>p</code>，页面区域总高度为<code>h</code>时，新的中心点在哪呢？</p>\n<p>对于这个问题我们可以先画个辅助图：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5dbf1ab0929e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>区域总高度为<code>h</code>，上区域高度为<code>p</code>，坐标轴<code>X、Y</code>过原点<code>O</code>，很容易推导出上区域中心点<code>A</code>的<code>Y</code>轴取值为<code>y = h/2-p/2</code>；</p>\n<p>当上区域高度<code>p</code>在总高度<code>h</code>中的比例为<code>percent</code>时，也就是说<code>p = h*percent</code>，那么公式可以写成<code>y = h/2 - h*percent/2</code>，进一步简化可以得到<code>y = h(0.5-percent/2)</code>。</p>\n<p>根据上述公式可以实现设置魔方区域的函数：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第116行至125行 */</span>\n<span class="hljs-title function_">resizeHeight</span>(<span class="hljs-params">percent, transformTag</span>) {\n    <span class="hljs-keyword">if</span> (percent &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>) {\n      percent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>;\n    }\n    <span class="hljs-keyword">if</span> (percent &gt; (<span class="hljs-number">1</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>)) {\n      percent = <span class="hljs-number">1</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>;\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(percent, percent, percent);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> * (<span class="hljs-number">0.5</span> - percent / <span class="hljs-number">2</span>) * transformTag;\n}\n</code></pre>\n<p><code>percent</code>表示魔方所占区域的<code>百分比</code>，<code>transformTag</code>表示中心的<code>变换方向</code>，<code>负号</code>表示向着 Y 轴负方向移动，<code>正号</code>表示向着 Y 轴正方向移动；</p>\n<p><code>minPercent</code>表示魔方所占区域的<code>最小值</code>，因为魔方所占区域的大小会随着滑动条的滑动而变化，滑动条靠近顶部或者底部时，魔方所占区域会很小，以至于看不清而且也无法操作，因此需要设置一个最小值；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第20行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">minPercent</span> = <span class="hljs-number">0.25</span>;<span class="hljs-comment">//正反视图至少占25%区域</span>\n</code></pre>\n<p><code>this.group.scale.set(percent, percent, percent)</code>则是对魔方进行缩放从而改变其大小，三个参数分别表示在<code>X轴</code>、<code>Y轴</code>和<code>Z轴</code>的缩放倍数；</p>\n<p>对于<code>this.group.position.y = this.main.originHeight * (0.5 - percent / 2) * transformTag</code>除了需要注意<code>transformTag</code>还需要注意<code>originHeight</code>表示的是<code>透视投影相机中原点所在裁切面</code>的高度；</p>\n<p>虽然最终效果是为了控制魔方在屏幕上显示时所占区域的大小，但是代码中的<code>originHeight</code>并不能直接使用屏幕高度；</p>\n<p>主要是因为屏幕的上的内容都是 3D 场景通过透视投影相机投影之后的效果，originHeight 应该等于魔方上下移动时其中心点所在平面的高度，而初始化魔方时指定其中心点在原点，也就是说<code>originHeight</code>等于过原点且垂直于<code>相机-原点</code>向量的平面的高度；</p>\n<p>感觉比较拗口的话，可以看示例图：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5de8e966c82e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>这是透视投影相机的示例图，在<code>ThreeJS基础</code>那一章也出现过，不同的地方在于在过坐标系原点的位置多了一个同时平行于<code>近平面</code>和<code>远平面</code>的裁切面，其高度就是代码中的<code>originHeight</code>，这个裁切面也就是所谓的<code>透视投影相机中原点所在裁切面</code>。</p>\n<p>在求透视投影相机中原点所在裁切面的高度之前需要弄清楚一个问题；在<code>ThreeJS基础</code>那一章曾介绍过创建<code>透视投影相机</code>时需要设置<code>视角</code>、<code>近平面距离</code>、<code>远平面距离</code>以及<code>裁切面宽高比</code>四个参数，但是你仔细想过这几个参数是怎么相互配合决定相机的可视区域的吗？</p>\n<p>你可能会想当然的觉得<code>视角</code>决定了<code>相机的观察范围（示例图中锥形区域）</code>，然后<code>近平面距离</code>和<code>远平面距离</code>则又从该锥形区域中选取一部分，最终确定为可视区域；</p>\n<p>如果是这样的话，创建相机时根本就不需要<code>裁切面宽高比</code>这个参数了，因为你已经默认<code>视角</code>既是水平视角又是垂直视角，然后锥形区域裁切面宽高比肯定为 1 且不能改变；</p>\n<p>真实的情况是参数中的<code>视角</code>表示的是<code>垂直视角</code>，设置了垂直视角只能决定相机观察区域的的上下范围，上下范围确定之后配合<code>裁切面宽高比</code>才能决定相机观察区域的水平范围。</p>\n<p>明确了垂直视角之后就可以求透视投影相机中原点所在裁切面的高度了，如图所示：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5e05c2889ec7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><code>α</code>为创建相机时设定的垂直视角，<code>z</code>表示相机离裁切面的距离，<code>h</code>为裁切面的高度，公式如下：</p>\n<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">h</span> = tan(α/<span class="hljs-number">2</span>)*z*<span class="hljs-number">2</span>\n</code></pre>\n<p>程序中垂直视角为<code>45</code>度，<code>z</code>等于相机的<code>Z</code>轴坐标，<code>Math.tan</code>参数为弧度，最终可得：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第57行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">originHeight</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(<span class="hljs-number">22.5</span>/<span class="hljs-number">180</span>*<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>)*<span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>*<span class="hljs-number">2</span>;\n</code></pre>\n<p>在实现滑动控制区域大小功能之前，先固定正反视图分别占一半区域；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第82、87行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">resizeHeight</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">resizeHeight</span>(<span class="hljs-number">0.5</span>,-<span class="hljs-number">1</span>);\n</code></pre>\n<p>此时编译运行即可看到如下效果：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/1672694004c727e2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h3 data-id="heading-6">3. 增加控制条；</h3>\n<p>控制条素材图片如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/16/167182c3c4bf0041~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>新增<code>images</code>目录用于存放项目中需要用到的图片素材，并在<code>object</code>目录中新增<code>TouchLine.js</code>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/17/16720d35c366b7c0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在 3D 场景中绘制 2D 的 UI 元素，目前想到的解决办法是选取 3D 场景中的某个平行于屏幕的平面，然后把 UI 元素绘制到上边去。</p>\n<p>因为在控制正反视图所占区域比例时使用的是<code>透视投影相机中原点所在裁切面</code>，因此为了方便计算（<code>因为我们已经求出了该裁切面的宽度和高度了，绘制UI图片时可以直接根据裁切面的尺寸和图片的实际尺寸比较得到缩放比例</code>），控制条也绘制到这个裁切面。</p>\n<p>完整实现代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js */</span>\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'../threejs/three.js\'</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchLine</span> {\n\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">main</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span> = main;\n        \n        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n        \n        <span class="hljs-comment">//实际尺寸</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> = <span class="hljs-number">750</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> = <span class="hljs-number">64</span>;\n        \n        <span class="hljs-comment">//逻辑尺寸</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span>;\n        \n        <span class="hljs-comment">//加载图片</span>\n        <span class="hljs-keyword">var</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();\n        loader.<span class="hljs-title function_">load</span>(<span class="hljs-string">\'images/touch-line.png\'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">texture</span>) {\n            <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(self.<span class="hljs-property">width</span>, self.<span class="hljs-property">height</span>);\n            <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n            self.<span class="hljs-property">plane</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\n            self.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n            self.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(self.<span class="hljs-property">plane</span>)\n        }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((xhr.<span class="hljs-property">loaded</span> / xhr.<span class="hljs-property">total</span> * <span class="hljs-number">100</span>) + <span class="hljs-string">\'% loaded\'</span>);\n        }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'An error happened\'</span>);\n        });\n    }\n}\n</code></pre>\n<h4 data-id="heading-7">3.1 加载素材图片</h4>\n<p>首先在代码中定义素材图片的<code>实际尺寸</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第12、13行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> = <span class="hljs-number">750</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> = <span class="hljs-number">64</span>;\n</code></pre>\n<p>然后再定义<code>逻辑尺寸</code>，所谓的逻辑尺寸是指把图片等比例缩放绘制到目标平面后的宽高；</p>\n<p>因为要保证图片完全展示，因此逻辑尺寸的宽度肯定等于目标平面的宽度；前边计算过目标平面的高度<code>originHeight</code>，根据<code>透视投影相机中所有裁切面的宽高比不变</code>，在已知高度的情况下，可以求出其宽度；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第57行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">originWidth</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">originHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">aspect</span>;\n</code></pre>\n<p>因为还有其它对象也需要用到<code>originWidth</code>变量，因此把它定义在<code>main.js</code>文件中。</p>\n<p>综上所述逻辑尺寸定义如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第16、17行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span>;\n</code></pre>\n<p>因为涉及到外部图片素材，因此需要用到 ThreeJS 框架提供的加载器；ThreeJS 框架提供了各种各样的加载器，方便开发者在程序中使用，比如：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/17/16720f78d0b4d18c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>有的用来加载字体，比如<code>FontLoader</code>；有的用来加载音频，比如<code>AudioLoader</code>；有的用来加载 3D 模型，比如<code>OBJLoader</code>；还有的则可以用来加载图片，比如后边会用到的<code>TextureLoader</code>；</p>\n<p>使用<code>纹理加载器</code>加载图片的用法很简单，只需先创建，然后执行其<code>load</code>方法即可；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第28行至第40行 */</span>\n<span class="hljs-keyword">var</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();\nloader.<span class="hljs-title function_">load</span>(<span class="hljs-string">\'images/touch-line.png\'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">texture</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(texture);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(texture.<span class="hljs-property">image</span>);\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(texture.<span class="hljs-property">image</span>.<span class="hljs-property">width</span>+<span class="hljs-string">\' \'</span>+texture.<span class="hljs-property">image</span>.<span class="hljs-property">height</span>);\n}, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((xhr.<span class="hljs-property">loaded</span> / xhr.<span class="hljs-property">total</span> * <span class="hljs-number">100</span>) + <span class="hljs-string">\'% loaded\'</span>);\n}, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'An error happened\'</span>);\n});\n</code></pre>\n<p>在<code>加载图片</code>时需要先设置图片的路径，然后定义好回调方法；在加载成功的回调函数中可以直接获得由图片生成的纹理对象，图片被保存在纹理对象的<code>image</code>属性中。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/17/1672103a5130762e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-8">3.2 绘制控制条</h4>\n<p>在明确了<code>绘制到什么地方</code>以及<code>怎么加载图片素材</code>这两个问题之后，还有一个问题需要解决，<code>用什么绘制？</code>。</p>\n<p>比如说要在 3D 场景中绘制一个小方块，可以使用<code>BoxGeometry</code>对象；那现在要在 3D 场景中绘制 2D 的 UI 元素应该用啥呢？</p>\n<p>ThreeJS 框架提供了<code>PlaneGeometry</code>对象，用来创建平面，刚好可以用来绘制 2D 的 UI 元素；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第30行至第34行 */</span>\n<span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(self.<span class="hljs-property">width</span>, self.<span class="hljs-property">height</span>);\n<span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\nself.<span class="hljs-property">plane</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\nself.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\nself.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(self.<span class="hljs-property">plane</span>);\n</code></pre>\n<p>在纹理加载器的成功回调函数中，创建好轮廓、纹理、材质之后就可以绘制控制条了，设置好位置，然后把它加入到场景中即可；</p>\n<p>在一般情况下 UI 元素不应该受到光照的影响，因此这里使用基础材质对象<code>MeshBasicMaterial</code>。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第4行 */</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">TouchLine</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/TouchLine.js\'</span>\n\n<span class="hljs-comment">/* main.js 第90行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TouchLine</span>(<span class="hljs-variable language_">this</span>);\n</code></pre>\n<p>最后在<code>main.js</code>中引入并在初始化物体<code>initObject</code>函数中创建<code>TouchLine</code>对象就可以看到如下效果了：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/1672692c7228def5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-9">3.3 控制条支持拖拽</h4>\n<p>目前只是把控制条绘制出来了，并不能用手指拖拽然后控制正反两个视图所占区域的大小，要实现这个功能需要监听触摸事件；</p>\n<p>在微信小游戏以及 ThreeJS 框架中并没有像浏览器那样支持对每个元素绑定事件监听，要判断是否在拖拽控制条，只能是获得手指在屏幕上触摸的位置坐标，然后根据坐标计算是否在控制条的范围内，如果在控制条的范围内则认为是在拖拽控制条，如果不在则认为没有拖拽控制条。</p>\n<p>要获得手指在屏幕上触摸的坐标位置，需要使用微信小游戏提供的全局触摸事件监听；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第97行至第101行 */</span>\n<span class="hljs-title function_">initEvent</span>(<span class="hljs-params"></span>) {\n    wx.<span class="hljs-title function_">onTouchStart</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchStart</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n    wx.<span class="hljs-title function_">onTouchMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchMove</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n    wx.<span class="hljs-title function_">onTouchEnd</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchEnd</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));\n}\n</code></pre>\n<p><code>onTouchStart</code>表示监听开始触摸事件，<code>onTouchMove</code>表示监听触摸移动事件，<code>onTouchEnd</code>监听触摸结束事件；其回调函数分别为<code>touchStart</code>、<code>touchMove</code>、<code>touchMove</code>。</p>\n<ul>\n<li>触摸开始回调函数</li>\n</ul>\n<pre><code class="hljs language-js" lang="js">    <span class="hljs-comment">/* main.js 第106行至第112行 */</span>\n    <span class="hljs-title function_">touchStart</span>(<span class="hljs-params">event</span>){\n        <span class="hljs-keyword">var</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>];\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(touch);\n    }\n</code></pre>\n<p>在触摸开始回调函数中可以通过<code>event</code>事件对象获得开始触摸点的屏幕坐标，因为不需要考虑多指触控操作，因此以触摸点数组中的第一个元素坐标为准。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/17/1672142aca2b95c9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>获得开始触摸点的屏幕坐标之后，还需要获得控制条的<code>屏幕尺寸</code>才能进行判断；控制条刚好占满屏幕，因此其屏幕宽度等于屏幕的宽度，再然后根据等比缩放的原则可以得到其屏幕高度；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第20行至第23行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span> = {\n    <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,\n    <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> * <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / self.<span class="hljs-property">realWidth</span>\n}\n</code></pre>\n<p>因为控制条默认位置在屏幕中间，已知其屏幕尺寸就可以求出其左上角顶点的屏幕坐标了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第24、25行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> = <span class="hljs-number">0</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> / <span class="hljs-number">2</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;\n</code></pre>\n<p>为了防止大家混淆，这里再重申下一个 UI 元素涉及的三个尺寸：</p>\n<ol>\n<li><code>实际尺寸</code>：因为这里的 UI 元素完全由图片构成，因此这里的实际尺寸其实就是指<code>图片的实际尺寸</code>；</li>\n<li><code>逻辑尺寸</code>：因为需要把 UI 元素绘制到 3D 场景中，因此绘制时需要知道 UI 元素<code>在 3D 场景坐标系中的位置以及尺寸</code>，也就是逻辑尺寸；</li>\n<li><code>屏幕尺寸</code>：把 UI 元素绘制到 3D 场景之后会被渲染到屏幕上，此时<code>展现在屏幕中的尺寸</code>就是屏幕尺寸。</li>\n</ol>\n<p>在知道控制条屏幕尺寸之后，就可以通过<code>边界</code>判断触摸点是否在控制条范围之内了。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第82至88行 */</span>\n<span class="hljs-title function_">isHover</span>(<span class="hljs-params">touch</span>) {\n    <span class="hljs-keyword">var</span> isHover = <span class="hljs-literal">false</span>;\n    <span class="hljs-keyword">if</span> (touch.<span class="hljs-property">clientY</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> &amp;&amp; touch.<span class="hljs-property">clientY</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> &amp;&amp; touch.<span class="hljs-property">clientX</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> &amp;&amp; touch.<span class="hljs-property">clientX</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">width</span>) {\n        isHover = <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">return</span> isHover;\n}\n</code></pre>\n<p>在触摸开始事件回调中使用<code>startPoint</code>变量记录触摸开始坐标，当触摸开始坐标在控制条范围内时，激活控制条，设置其状态为<code>正在被操控</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第106行至第112行 */</span>\n<span class="hljs-title function_">touchStart</span>(<span class="hljs-params">event</span>){\n    <span class="hljs-keyword">var</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> = touch;\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-title function_">isHover</span>(touch)) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-title function_">enable</span>();\n    }\n}\n</code></pre>\n<p>之所以需要设置状态，是因为后续还会增加一些 UI 元素，比如<code>打乱按钮</code>、<code>重置按钮</code>、<code>存档按钮</code>、<code>读取按钮</code>等；另外还有魔方整体转动以及操作魔方等都依赖于微信小游戏提供的全局触摸事件监听，为了防止各种操作之间相互干扰，<code>需要在触摸开始事件就决定此次滑动是进行哪种特定的操作</code>。</p>\n<p>在<code>TouchLine</code>对象中新增两个方法，并使用<code>isActive</code>表示其<code>是否正在被操控</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第52行至第58行 */</span>\n<span class="hljs-title function_">enable</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">true</span>;\n}\n<span class="hljs-title function_">disable</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">false</span>;\n}\n</code></pre>\n<ul>\n<li>触摸移动回调函数</li>\n</ul>\n<p>在触摸移动回调函数中需要根据移动后触摸点的新坐标计算控制条的新位置并重新绘制；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第117行至第125行 */</span>\n<span class="hljs-title function_">touchMove</span>(<span class="hljs-params">event</span>){\n    <span class="hljs-keyword">var</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">isActive</span>) {<span class="hljs-comment">//滑动touchline</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-title function_">move</span>(touch.<span class="hljs-property">clientY</span>);\n        <span class="hljs-keyword">var</span> frontPercent = touch.<span class="hljs-property">clientY</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n        <span class="hljs-keyword">var</span> endPercent = <span class="hljs-number">1</span> - frontPercent;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rubikResize</span>(frontPercent, endPercent);\n    }\n}\n</code></pre>\n<p>同样是通过事件对象获得移动后触摸点的新坐标，如果控制条状态为已激活状态状态，就更新控制条位置；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第120行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-title function_">move</span>(touch.<span class="hljs-property">clientY</span>);\n</code></pre>\n<p><code>TouchLine</code>对象的<code>move</code>方法具体实现如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第60行至第77行 */</span>\n<span class="hljs-title function_">move</span>(<span class="hljs-params">y</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span>) {\n        <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span> || y &gt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * (<span class="hljs-number">1</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>)) {\n            <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>) {\n                y = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>;\n            } <span class="hljs-keyword">else</span> {\n                y = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> * (<span class="hljs-number">1</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">minPercent</span>);\n            }\n        }\n    \n        <span class="hljs-keyword">var</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - y;<span class="hljs-comment">//屏幕移动距离</span>\n        <span class="hljs-keyword">var</span> percent = len / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n        <span class="hljs-keyword">var</span> len2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> * percent;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> += len2;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> = y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;\n    }\n}\n</code></pre>\n<p>因为设置了正反视图所占区域的最小比例，因此更新控制条位置时需要根据这个比例计算控制条移动距离的阀值。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第70、71行 */</span>\n<span class="hljs-keyword">var</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - y;<span class="hljs-comment">//屏幕移动距离</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> = y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>;\n</code></pre>\n<p>移动后新触摸点即为控制条新的中心点，旧的中心点的纵坐标减去新的中心点的纵坐标即可得到此次控制条移动的距离，此外还得更新控制条左上角顶点的屏幕坐标。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* TouchLine.js 第73行至75行 */</span>\n<span class="hljs-keyword">var</span> percent = len / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n<span class="hljs-keyword">var</span> len2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> * percent;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> += len2;\n</code></pre>\n<p>因为得到的移动距离是在屏幕上移动的距离，而更新控制条位置时需要更新控制条在 3D 场景中的坐标；可以先求出屏幕移动距离占屏幕总高度的百分比，这个百分比和裁切面移动距离占裁切面总高度的百分比应该是相同的，就可以求出控制条在裁切面的移动距离，然后更新控制条的 Y 轴坐标即可。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第121行至第123行 */</span>\n<span class="hljs-keyword">var</span> frontPercent = touch.<span class="hljs-property">clientY</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;\n<span class="hljs-keyword">var</span> endPercent = <span class="hljs-number">1</span> - frontPercent;\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rubikResize</span>(frontPercent, endPercent);\n</code></pre>\n<p>控制条位置更新之后，还需要更新正反视角魔方的位置，先计算新的占比，然后根据新的占比更新位置；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第146行至149行 */</span>\n<span class="hljs-title function_">rubikResize</span>(<span class="hljs-params">frontPercent, endPercent</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">resizeHeight</span>(frontPercent, <span class="hljs-number">1</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">resizeHeight</span>(endPercent, -<span class="hljs-number">1</span>);\n}\n</code></pre>\n<p>更新位置时只需要调用魔方对象的<code>rubikResize</code>方法即可。</p>\n<ul>\n<li>触摸结束回调函数</li>\n</ul>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第130至132行 */</span>\n<span class="hljs-title function_">touchEnd</span>(<span class="hljs-params"></span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-title function_">disable</span>();\n}\n</code></pre>\n<p>在触摸结束回调函数中目前只需要做一件事，把控制条的状态设置为未激活状态，表示此次滑动拖拽结束。</p>\n<h4 data-id="heading-10">3.4 去掉视角控制器干扰</h4>\n<p>一切都 OK 了吗？</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/167269176342e0e7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>其实并没有，上述绘制 UI 元素的方法存在一个问题，即当相机位置变化时，如果 UI 元素的位置没有跟着变化，就会出现上边那种情况；</p>\n<p>解决办法有两个，第一个是 UI 元素的位置随着相机位置的变化而变化，使得 UI 元素始终正面朝向相机；第二个办法是固定相机位置；</p>\n<p>这里采用第二个办法，主要原因在于<code>对于魔方小游戏来说，太自由的视角控制反而不好，会让人感觉整个操作过程比较难控制</code>。</p>\n<p>固定相机位置需要去掉动态改变其位置的控制器；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/167266c81629d017~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/167266eb0d57ba3c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>去掉之后就基本正常了。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/16726900b771bc5e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h4 data-id="heading-11">3.5 优化</h4>\n<p>到此还有最后一个问题需要解决，现在的正反视图只能看到魔方的两个面；</p>\n<p>要解决这个问题则需要对魔方再做一些的位移变换，确保正反视角魔方均有三个面可见；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第103行至108行 */</span>\n<span class="hljs-keyword">if</span>(type==<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">frontViewName</span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">rotateY</span>(<span class="hljs-number">45</span>/<span class="hljs-number">180</span>*<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);\n}<span class="hljs-keyword">else</span>{\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">rotateY</span>((<span class="hljs-number">270</span>-<span class="hljs-number">45</span>) / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);\n}\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">rotateOnAxis</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">25</span> / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);\n</code></pre>\n<p>在 ThreeJS 框架中<code>Object3D</code>对象有很多进行位移变换的函数以及属性；</p>\n<p>其中<code>rotateY</code>顾名思义是绕 Y 轴旋转，<code>this.group.rotateY(45/180*Math.PI)</code>表示绕 Y 轴水平转动 45 度，这样就可以看到魔方的两个侧面了；</p>\n<p><code>rotateOnAxis</code>则表示绕某个向量旋转，当魔方需要绕着其对角线转动时，知道其对角线向量为<code>new THREE.Vector3(1, 0, 1)</code>，传入到<code>rotateOnAxis</code>方法中即可；</p>\n<p><code>this.group.rotateOnAxis(new THREE.Vector3(1, 0, 1), 25 / 180 * Math.PI)</code>表示魔方绕着其对角线在垂直方向旋转 25 度，这样就可以看到正视角魔方的上表面和反视视角魔方的下表面了。</p>\n<p>最后就实现了如下效果：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/18/167268e0ceb28f79~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-12">总结</h2>\n<p>在这一章中我们学会了如何实现魔方小游戏的正反视图功能；在绘制 UI 元素时需要注意尺寸问题，<code>对于图形相关的问题想不明白的时候就画个图试试！</code></p></div>',
  },
  {
    name: "6\n魔方转动\n学习时长: 81分27秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">魔方转动</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>实现魔方微信小游戏转动功能；</li>\n<li>魔方转动分析及实现；</li>\n<li>ThreeJS 框架<code>Raycaster</code>射线对象的作用、使用方法以及返回结果分析；</li>\n<li>利用ThreeJS 框架的<code>Raycaster</code>对象把 2D 屏幕滑动映射为 3D 空间滑动并计算滑动向量；</li>\n<li>了解多坐标系的相关概念并解决实际问题；</li>\n<li>ThreeJS 框架中已知两点坐标计算向量；</li>\n<li>ThreeJS 框架中已知两三维向量计算它们之间的夹角；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象<code>id</code>属性的性质及规律；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象的<code>matrixWorld</code>属性相关知识；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象使用<code>applyMatrix</code>方法进行矩阵变换；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象<code>rotateX</code>、<code>rotateY</code>、<code>rotateZ</code>等旋转方法的性质并举例说明运用不当的情形；</li>\n<li><code>3D空间绕着过某一点的向量旋转一定角度</code>的矩阵实现；</li>\n<li>在ThreeJS 框架中使用微信小游戏提供的<code>requestAnimationFrame</code>实现旋转动画。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p><code>魔方转动</code>如下图所示：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5eab36667d84~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo4" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo4" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/16753fa20bb369a4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">实现</h2>\n<p>首先需要分析转动魔方操作：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5ea4fc677e6e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>如图当手指触摸<code>G点</code>按<code>GH</code>方向滑动时，魔方<code>竖直</code>方向的<code>上层</code>将会绕<code>Y轴</code>向<code>右</code>转动；而同样是当手指触摸<code>G点</code>按<code>GA</code>方向滑动时，魔方<code>水平</code>方向的<code>中层</code>将会绕<code>X轴</code>向<code>下</code>转动；</p>\n<p>由此可见转动魔方首先得<code>获得手指的触摸点坐标</code>，知道了触摸点坐标就可以根据触摸点是否在魔方上判断此次滑动是否会转动魔方；如果触摸点在魔方上再根据触摸点坐标和滑动点坐标就可以<code>计算出滑动方向</code>；</p>\n<p>魔方有且仅有六个转动方向，分别是<code>X轴正方向</code>、<code>X轴负方向</code>、<code>Y轴正方向</code>、<code>Y轴负方向</code>、<code>Z轴正方向</code>和<code>X轴正方向</code>；计算出滑动方向后可以判断滑动方向和这六个方向的夹角，夹角最小的即为<code>转动方向</code>；</p>\n<p>但是只依赖转动方向其实是不能确定转动魔方操作的，比如图中从<code>E点</code>滑动到<code>F点</code>和从<code>G点</code>滑动到<code>H点</code>，滑动方向都是<code>X轴</code>的正方向，但这其实是两种不同的情形；对于这种情况还需要依靠<code>触摸小方块</code>和<code>滑动平面</code>来区分；</p>\n<p>比如图中从<code>E点</code>滑动到<code>F点</code>，触摸小方块是上层正面中间的那个小方块，而且滑动平面是魔方<code>Y轴</code>正方向平面；从<code>G点</code>滑动到<code>H点</code>，触摸小方块虽然相同，但是滑动平面是魔方<code>Z轴</code>正方向平面。</p>\n<p>已知转动方向、触摸小方块以及滑动平面就可以<code>计算出此次转动魔方操作所涉及的小方块</code>；</p>\n<p>知道了转动方向和转动元素就可以确定转动操作了，另外从用户体验的角度考虑还需要<code>实现转动动画</code>。</p>\n<h3 data-id="heading-4">计算触摸点坐标和滑动平面</h3>\n<p>微信小游戏提供的全局触摸事件监听只能获得手指在屏幕上的坐标，ThreeJS 框架出于<code>3D场景交互</code>方面的考虑提供了<code>Raycaster</code>射线对象，它能帮助我们在只知道手指触摸或者鼠标点击的 2D 屏幕坐标的情况下推测出在 3D 场景中被选中的物体；</p>\n<p>可以简单理解成从相机位置发射一条光线穿过空间中目标点位置，然后得到 3D 场景中该光线会碰撞的物体的信息，包括距离、碰撞点、碰撞平面等。</p>\n<p>使用方法很简单：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第22行至第26行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">raycaster</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Raycaster</span>();\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span>;\n</code></pre>\n<p>执行<code>new THREE.Raycaster()</code>即可创建碰撞射线对象，同时定义一些其它的相关变量:</p>\n<ul>\n<li><code>intersect</code>表示转动魔方时手指触碰的小方块；</li>\n<li><code>normalize</code>表示转动魔方时手指触碰的平面的法向量；</li>\n<li><code>targetRubik</code>表示转动魔方时手指触碰的魔方；</li>\n<li><code>anotherRubik</code>表示转动魔方时手指没触碰的魔方；</li>\n</ul>\n<p>计算触摸点坐标和滑动平面函数的完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第205行至第243行 */</span>\n<span class="hljs-title function_">getIntersects</span>(<span class="hljs-params">event</span>) {\n    <span class="hljs-keyword">var</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-keyword">var</span> mouse = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>();\n    mouse.<span class="hljs-property">x</span> = (touch.<span class="hljs-property">clientX</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;\n    mouse.<span class="hljs-property">y</span> = -(touch.<span class="hljs-property">clientY</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;\n    \n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">raycaster</span>.<span class="hljs-title function_">setFromCamera</span>(mouse, <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>);\n    \n    <span class="hljs-keyword">var</span> rubikTypeName;\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> &gt; touch.<span class="hljs-property">clientY</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n        rubikTypeName = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> &lt; touch.<span class="hljs-property">clientY</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n        rubikTypeName = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endViewName</span>;\n    }\n    <span class="hljs-keyword">var</span> targetIntersect;\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) {\n        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>[i].<span class="hljs-property">childType</span> == rubikTypeName) {\n            targetIntersect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>[i];\n            <span class="hljs-keyword">break</span>;\n        }\n    }\n    \n    <span class="hljs-keyword">if</span> (targetIntersect) {\n        <span class="hljs-keyword">var</span> intersects = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raycaster</span>.<span class="hljs-title function_">intersectObjects</span>(targetIntersect.<span class="hljs-property">children</span>);\n        <span class="hljs-keyword">if</span> (intersects.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">2</span>) {\n            <span class="hljs-keyword">if</span> (intersects[<span class="hljs-number">0</span>].<span class="hljs-property">object</span>.<span class="hljs-property">cubeType</span> === <span class="hljs-string">\'coverCube\'</span>) {\n                <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span> = intersects[<span class="hljs-number">1</span>];\n                <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span> = intersects[<span class="hljs-number">0</span>].<span class="hljs-property">face</span>.<span class="hljs-property">normal</span>;\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span> = intersects[<span class="hljs-number">0</span>];\n                <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span> = intersects[<span class="hljs-number">1</span>].<span class="hljs-property">face</span>.<span class="hljs-property">normal</span>;\n            }\n        }\n    }\n}\n</code></pre>\n<p><code>getIntersects</code>方法用来获取转动魔方时的触摸点坐标以及该触摸点所在平面的法向量，传入的参数是微信小游戏的触摸事件对象<code>event</code>。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第206行至第209行 */</span>\n<span class="hljs-keyword">var</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>];\n<span class="hljs-keyword">var</span> mouse = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>();\nmouse.<span class="hljs-property">x</span> = (touch.<span class="hljs-property">clientX</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;\nmouse.<span class="hljs-property">y</span> = -(touch.<span class="hljs-property">clientY</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;\n</code></pre>\n<p>因为屏幕坐标系原点在屏幕左上角，而 ThreeJS 中世界坐标系原点被投影到屏幕中心，所以这里需要把原始的屏幕坐标转换为原点在屏幕中心的屏幕坐标，然后还要对其进行<code>归一化</code>处理，使坐标范围限制在<code>[-1,1]</code>区间内；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5f761129cc29~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><code>Raycaster</code>射线对象的初始化需要传入转换后的屏幕坐标以及相机对象；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第211行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">raycaster</span>.<span class="hljs-title function_">setFromCamera</span>(mouse, <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>);\n</code></pre>\n<p>每次碰撞检测其实没必要检测场景中的全部物体，比如如果触摸点的坐标在滑动条的上边，那么被转动的魔方肯定是正视角魔方，反之则是反视角魔方；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第213行至第229行 */</span>\n<span class="hljs-keyword">var</span> rubikTypeName;\n<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> &gt; touch.<span class="hljs-property">clientY</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n    rubikTypeName = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span>;\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> &lt; touch.<span class="hljs-property">clientY</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n    rubikTypeName = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endViewName</span>;\n}\n<span class="hljs-keyword">var</span> targetIntersect;\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>[i].<span class="hljs-property">childType</span> == rubikTypeName) {\n        targetIntersect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>[i];\n        <span class="hljs-keyword">break</span>;\n    }\n}\n</code></pre>\n<p>获得待检测的物体后只需要把其传入到<code>Raycaster</code>对象的<code>intersectObjects</code>方法即可；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第232行 */</span>\n<span class="hljs-keyword">var</span> intersects = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raycaster</span>.<span class="hljs-title function_">intersectObjects</span>(targetIntersect.<span class="hljs-property">children</span>);\n</code></pre>\n<p>在触摸开始事件的回调函数<code>touchStart</code>中执行<code>getIntersects</code>方法。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第121行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getIntersects</span>(event);\n</code></pre>\n<p>输出碰撞检测的元素<code>intersects</code>就会发现：</p>\n<p>当我们点击空白区域时，<code>intersects</code>为空数组；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/167546a6f78c0340~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>但是当我们点击魔方区域<code>蓝色面的红点</code>时，<code>intersects</code>就会是由近到远的碰撞元素数组了；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/167547045fc4fbbb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>需要注意以下几点：</p>\n<ol>\n<li>数组中的元素是按距离的先后顺序排列的，可以从<code>distance</code>属性看出，而且该距离是碰撞点离相机位置的距离；</li>\n<li>数组元素的<code>object</code>属性表示是碰撞物体；</li>\n<li>数组元素的<code>point</code>属性表示是碰撞点在世界坐标系中的坐标；</li>\n<li>数组元素的<code>face</code>属性表示碰撞点在碰撞物体所在的面，其中<code>normal</code>属性表示面的法向量，图中法向量为<code>(x:0,y:-1:z:1)</code>和<code>Z轴</code>一样，<code>但是这里的Z轴并不是世界坐标系的Z轴，世界坐标系的Z轴是垂直于屏幕向外的；这里的Z轴是小方块自身坐标系的Z轴</code>。</li>\n</ol>\n<p>当我们使用一个坐标系来描绘整个场景的时候，场景中的任意点都可以用该坐标系描述，因此理论上只需要一个<code>世界坐标系</code>就可以了；<code>自身坐标系</code>又是啥呢？</p>\n<p>这就涉及到多坐标系的概念，简单来说<code>世界坐标系</code>就是最大的坐标系，也被称为全局坐标；<code>自身坐标系</code>也被称为<code>物体坐标系</code>，每一个物体都有独立的坐标系，物体和与之关联的坐标系的关系不会随着物体在世界坐标系中的变换而变化；</p>\n<p>举例来说：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5f31f8b8774b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><code>X-Y-Z坐标系</code>就是世界坐标系，<code>X1-Y1-Z1坐标系</code>为小方块的自身坐标系，初始状态时世界坐标系的<code>X轴</code>和小方块自身坐标系的<code>X1轴</code>方向相同，<code>Y轴</code>和<code>Y1轴</code>以及<code>Z轴</code>和<code>Z1轴</code>的关系也一样；但当小方块绕着自身坐标系的<code>X1轴</code>向下旋转 90 度之后，世界坐标系和小方块自身坐标系的关系就发生了变化；</p>\n<p>正因为如此我们判断触摸平面时根据触摸小方块碰撞平面的法向量来判断会<code>比较复杂</code>，因为刚开始如果触摸小方块碰撞平面的法向量为<code>Y1</code>和<code>Y</code>的坐标相同都是<code>(0,1,0)</code>，那么触摸平面为魔方上表面；</p>\n<p>但是此次操作之后小方块转动到了别的位置，再触摸魔方的上表面时触摸小方块碰撞平面的法向量就不一定和<code>Y</code>的坐标相同了；</p>\n<p>为了<code>简化判断滑动平面逻辑</code>需要在所有小方块外层加一层透明的大方块：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第159行至第169行 */</span>\n<span class="hljs-keyword">var</span> width = <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">num</span> * <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span>;\n<span class="hljs-keyword">var</span> cubegeo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(width, width, width);\n<span class="hljs-keyword">var</span> hex = <span class="hljs-number">0x000000</span>;\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cubegeo.<span class="hljs-property">faces</span>.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {\n  cubegeo.<span class="hljs-property">faces</span>[i].<span class="hljs-property">color</span>.<span class="hljs-title function_">setHex</span>(hex);\n  cubegeo.<span class="hljs-property">faces</span>[i + <span class="hljs-number">1</span>].<span class="hljs-property">color</span>.<span class="hljs-title function_">setHex</span>(hex);\n}\n<span class="hljs-keyword">var</span> cubemat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">vertexColors</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">FaceColors</span>, <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(cubegeo, cubemat);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">cubeType</span> = <span class="hljs-string">\'coverCube\'</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>);\n</code></pre>\n<p>创建物体设置材质这种基本流程没必要再详情说了，唯一注意的是在初始化基础材质时，如果想要它透明只需要指定其参数<code>opacity</code>为<code>0</code>即可；</p>\n<p>因为转动魔方时操作的都是小方块，因此<code>外层透明大方块的自身坐标系和逻辑上的魔方对象的自身坐标系始终是相同的</code>，如果外层透明大方块碰撞平面法向量为其坐标系的<code>Y轴</code>，那么滑动平面肯定为魔方上平面，以此类推。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第234行至第240行 */</span>\n<span class="hljs-keyword">if</span> (intersects[<span class="hljs-number">0</span>].<span class="hljs-property">object</span>.<span class="hljs-property">cubeType</span> === <span class="hljs-string">\'coverCube\'</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span> = intersects[<span class="hljs-number">1</span>];\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span> = intersects[<span class="hljs-number">0</span>].<span class="hljs-property">face</span>.<span class="hljs-property">normal</span>;\n} <span class="hljs-keyword">else</span> {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span> = intersects[<span class="hljs-number">0</span>];\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span> = intersects[<span class="hljs-number">1</span>].<span class="hljs-property">face</span>.<span class="hljs-property">normal</span>;\n}\n</code></pre>\n<p>另外因为外层透明大方块刚好包含所有小方块，由于浮点数精度问题，在碰撞元素数组中可能在第一项也可能在第二项，根据自定义属性区分以下就好了。</p>\n<h3 data-id="heading-5">计算滑动方向</h3>\n<p>滑动点的坐标减去触摸点的坐标即可得到滑动向量；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第27行至第29行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>;<span class="hljs-comment">//触摸点</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>;<span class="hljs-comment">//滑动点</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> = <span class="hljs-literal">false</span>;<span class="hljs-comment">//魔方是否正在转动</span>\n</code></pre>\n<p>先定义好相关变量，转动魔方后会有一段时间的转动动画，在这段时间内不能再进行下一次转动判断，因此定义<code>this.isRotating</code>变量来标识魔方的状态。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第122行至第124行 */</span>\n<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>) {<span class="hljs-comment">//触摸点在魔方上且魔方没有转动</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>.<span class="hljs-property">point</span>;<span class="hljs-comment">//开始转动，设置起始点</span>\n}\n</code></pre>\n<p>在触摸开始事件的回调函数<code>touchStart</code>中进行判断，如果魔方没有转动且触摸点在魔方上，那么就记录当前碰撞点为起始点。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第139行至第145行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getIntersects</span>(event);\n<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>){<span class="hljs-comment">//滑动点在魔方上且魔方没有转动</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>.<span class="hljs-property">point</span>;\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>.<span class="hljs-title function_">equals</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>)){<span class="hljs-comment">//触摸点和滑动点不一样则意味着可以得到转动向量</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateRubik</span>();\n    }\n}\n</code></pre>\n<p>接着在触摸移动事件的回调函数<code>touchMove</code>中再进行判断，如果滑动点在魔方上且魔方没有转动，那么记录此时的碰撞点为滑动点；当滑动点坐标和触摸点坐标不一样时则意味着它们之间相减可以得到滑动方向，那么符合转动魔方的条件，执行<code>rotateRubik</code>方法。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第171行 */</span>\n<span class="hljs-keyword">var</span> sub = <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>);<span class="hljs-comment">//计算转动向量</span>\n</code></pre>\n<p>在<code>rotateRubik</code>方法中直接调用<code>Vector3</code>对象的<code>sub</code>方法即可得到滑动方向。</p>\n<h3 data-id="heading-6">计算转动方向</h3>\n<p>前边就阐述过魔方的转动方向有且只有六种，把这六种转动方向向量定义在<code>Rubik.js</code>中：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第87行至第92行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLine</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLineAd</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLine</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLineAd</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLine</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLineAd</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);\n</code></pre>\n<p>这六个方向向量中谁和滑动方向向量的夹角最小谁就是此次滑动的转动方向。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第190行至第196行 */</span>\n<span class="hljs-keyword">var</span> xAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLine</span>);\n<span class="hljs-keyword">var</span> xAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLineAd</span>);\n<span class="hljs-keyword">var</span> yAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLine</span>);\n<span class="hljs-keyword">var</span> yAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLineAd</span>);\n<span class="hljs-keyword">var</span> zAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLine</span>);\n<span class="hljs-keyword">var</span> zAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLineAd</span>);\n<span class="hljs-keyword">var</span> minAngle = <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [xAngle, xAngleAd, yAngle, yAngleAd, zAngle, zAngleAd]);<span class="hljs-comment">//最小夹角</span>\n</code></pre>\n<p>计算两个三维向量的夹角可以调用<code>Vector3</code>对象的<code>angleTo</code>方法。</p>\n<p>了解过多坐标系的概念之后，你应该会发现这里存在一个问题；</p>\n<p>我们计算的<code>sub</code>滑动向量是基于世界坐标系的，而刚刚定义的魔方的六种转动方向向量是基于魔方坐标系的，直接进行运算肯定不能得到我们想要的结果，需要把<code>sub</code>滑动向量转换到魔方坐标系或者把魔方的六种转动方向向量转换到世界坐标系。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第98行至第123行 */</span>\n<span class="hljs-title function_">updateCurLocalAxisInWorld</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">var</span> center = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> xPoint = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> xPointAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> yPoint = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> yPointAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> zPoint = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n    <span class="hljs-keyword">var</span> zPointAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);\n\n    <span class="hljs-keyword">var</span> matrix = <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">matrixWorld</span>;<span class="hljs-comment">//魔方的在世界坐标系的变换矩阵</span>\n    center.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    xPoint.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    xPointAd.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    yPoint.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    yPointAd.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    zPoint.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n    zPointAd.<span class="hljs-title function_">applyMatrix4</span>(matrix);\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">center</span> = center;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xLine</span> = xPoint.<span class="hljs-title function_">sub</span>(center);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">xLineAd</span> = xPointAd.<span class="hljs-title function_">sub</span>(center);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yLine</span> = yPoint.<span class="hljs-title function_">sub</span>(center);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">yLineAd</span> = yPointAd.<span class="hljs-title function_">sub</span>(center);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">zLine</span> = zPoint.<span class="hljs-title function_">sub</span>(center);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">zLineAd</span> = zPointAd.<span class="hljs-title function_">sub</span>(center);\n}\n</code></pre>\n<p>因为在 ThreeJS 框架中场景中的物体不管怎么变换都用<code>matrixWorld</code>属性保存了物体在世界坐标系变换矩阵，如果物体进行该矩阵逆矩阵的变换就会回到起始位置；同理如果知道该物体某个点在世界坐标系的起始坐标，那么只需要乘以该矩阵就可以得到该点在世界坐标系的最新坐标，也就不难求出魔方六个转动方向向量在世界坐标系的坐标了；</p>\n<p><code>updateCurLocalAxisInWorld</code>函数就能用来更新魔方自身坐标系坐标轴在世界坐标系的坐标。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5f38461840ca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第206行至第217行 */</span>\n<span class="hljs-keyword">case</span> <span class="hljs-attr">xAngle</span>:\n    direction = <span class="hljs-number">0</span>;<span class="hljs-comment">//向x轴正方向旋转90度（还要区分是绕z轴还是绕y轴）</span>\n    <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLine)) {\n      direction = direction + <span class="hljs-number">0.1</span>;<span class="hljs-comment">//绕z轴顺时针</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLineAd)) {\n      direction = direction + <span class="hljs-number">0.2</span>;<span class="hljs-comment">//绕z轴逆时针</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLine)) {\n      direction = direction + <span class="hljs-number">0.3</span>;<span class="hljs-comment">//绕y轴逆时针</span>\n    } <span class="hljs-keyword">else</span> {\n      direction = direction + <span class="hljs-number">0.4</span>;<span class="hljs-comment">//绕y轴顺时针</span>\n    }\n    <span class="hljs-keyword">break</span>;\n</code></pre>\n<p>假设滑动方向和<code>X轴</code>正方向的夹角最小，那么可以确定转动方向为<code>X轴</code>正方向；但是根据触摸平面的不同存在四种不同的转动情况：</p>\n<ul>\n<li>触摸平面在<code>Y轴</code>正方向平面，比如从<code>E点</code>滑动到<code>F点</code>，此时魔方应该是<code>绕Z轴顺时针转动</code>；</li>\n<li>触摸平面在<code>Y轴</code>负方向平面，比如从<code>C点</code>滑动到<code>D点</code>，此时魔方应该是<code>绕Z轴逆时针转动</code>；</li>\n<li>触摸平面在<code>Z轴</code>正方向平面，比如从<code>G点</code>滑动到<code>H点</code>，此时魔方应该是<code>绕Y轴逆时针转动</code>；</li>\n<li>触摸平面在<code>Z轴</code>负方向平面，比如从<code>A点</code>滑动到<code>B点</code>，此时魔方应该是<code>绕Y轴顺时针转动</code>。</li>\n</ul>\n<p>计算转动方向函数完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第186行至第282行 */</span>\n<span class="hljs-title function_">getDirection</span>(<span class="hljs-params">sub, normalize</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateCurLocalAxisInWorld</span>();\n    <span class="hljs-keyword">var</span> direction;\n    <span class="hljs-comment">//判断差向量和x、y、z轴的夹角</span>\n    <span class="hljs-keyword">var</span> xAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLine</span>);\n    <span class="hljs-keyword">var</span> xAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xLineAd</span>);\n    <span class="hljs-keyword">var</span> yAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLine</span>);\n    <span class="hljs-keyword">var</span> yAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yLineAd</span>);\n    <span class="hljs-keyword">var</span> zAngle = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLine</span>);\n    <span class="hljs-keyword">var</span> zAngleAd = sub.<span class="hljs-title function_">angleTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zLineAd</span>);\n    <span class="hljs-keyword">var</span> minAngle = <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [xAngle, xAngleAd, yAngle, yAngleAd, zAngle, zAngleAd]);<span class="hljs-comment">//最小夹角</span>\n\n    <span class="hljs-keyword">var</span> xLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> xLineAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> yLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> yLineAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> zLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n    <span class="hljs-keyword">var</span> zLineAd = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);\n\n    <span class="hljs-keyword">switch</span> (minAngle) {\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">xAngle</span>:\n            direction = <span class="hljs-number">0</span>;<span class="hljs-comment">//向x轴正方向旋转90度（还要区分是绕z轴还是绕y轴）</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;<span class="hljs-comment">//绕z轴顺时针</span>\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;<span class="hljs-comment">//绕z轴逆时针</span>\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;<span class="hljs-comment">//绕y轴逆时针</span>\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;<span class="hljs-comment">//绕y轴顺时针</span>\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">xAngleAd</span>:\n            direction = <span class="hljs-number">1</span>;<span class="hljs-comment">//向x轴反方向旋转90度</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">yAngle</span>:\n            direction = <span class="hljs-number">2</span>;<span class="hljs-comment">//向y轴正方向旋转90度</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(xLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">yAngleAd</span>:\n            direction = <span class="hljs-number">3</span>;<span class="hljs-comment">//向y轴反方向旋转90度</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(zLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(xLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">zAngle</span>:\n            direction = <span class="hljs-number">4</span>;<span class="hljs-comment">//向z轴正方向旋转90度</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(xLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-attr">zAngleAd</span>:\n            direction = <span class="hljs-number">5</span>;<span class="hljs-comment">//向z轴反方向旋转90度</span>\n            <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLine)) {\n                direction = direction + <span class="hljs-number">0.1</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(yLineAd)) {\n                direction = direction + <span class="hljs-number">0.2</span>;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalize.<span class="hljs-title function_">equals</span>(xLine)) {\n                direction = direction + <span class="hljs-number">0.3</span>;\n            } <span class="hljs-keyword">else</span> {\n                direction = direction + <span class="hljs-number">0.4</span>;\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-attr">default</span>:\n            <span class="hljs-keyword">break</span>;\n    }\n    <span class="hljs-keyword">return</span> direction;\n}\n</code></pre>\n<p>在转动魔方函数<code>rotateRubik</code>中计算滑动方向之后就可以调用<code>Rubik</code>对象的<code>getDirection</code>方法计算转动方向了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第172行 */</span>\n<span class="hljs-keyword">var</span> direction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-title function_">getDirection</span>(sub, <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span>);<span class="hljs-comment">//计算转动方向</span>\n</code></pre>\n<h3 data-id="heading-7">计算转动元素</h3>\n<p>在知道触摸点坐标和转动方向之后就可以计算此次转动所涉及的小方块元素了，办法有很多，比如可以对这些小方块编号；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/29/1675e542b6eed510~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>然后就会发现这些编号其实是存在一些规律的，比如：</p>\n<ul>\n<li><code>A/9==0</code> A 层小方块序号整除 9 都等于 0；</li>\n<li><code>B/9==1</code> B 层小方块序号整除 9 都等于 1；</li>\n<li><code>C/9==2</code> C 层小方块序号整除 9 都等于 2；</li>\n<li><code>D%3==2</code> D 层小方块序号取余 3 都等于 2；</li>\n<li><code>E%3==1</code> E 层小方块序号取余 3 都等于 1；</li>\n<li><code>F%3==0</code> F 层小方块序号取余 3 都等于 0；</li>\n<li><code>H%9/3==0</code> H 层小方块序号取余 9 然后再整除 3 都等于 0；</li>\n<li><code>I%9/3==1</code> I 层小方块序号取余 9 然后再整除 3 都等于 1；</li>\n<li><code>J%9/3==2</code> J 层小方块序号取余 9 然后再整除 3 都等于 2。</li>\n</ul>\n<p>这些规律的存在就可以帮助我们在已知触摸点所在小方块序号以及转动方向的情况下确定转动元素，比如从<code>O点</code>滑动到<code>P点</code>时，触摸点小方块<code>序号为1</code>，通过<code>getDirection</code>函数计算<code>转动方向为0.1</code>，此时<code>转动元素即为A层的所有小方块</code>，其序号满足<code>A/9==0</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第290行 */</span>\n<span class="hljs-keyword">var</span> numI = <span class="hljs-built_in">parseInt</span>(targetIndex / <span class="hljs-number">9</span>);\n\n<span class="hljs-comment">/* Rubik.js 第295行至第309行 */</span>\n<span class="hljs-keyword">case</span> <span class="hljs-number">0.1</span>:\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n      <span class="hljs-keyword">var</span> tempId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">cubeIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>;\n      <span class="hljs-keyword">if</span> (numI === <span class="hljs-built_in">parseInt</span>(tempId / <span class="hljs-number">9</span>)) {\n        boxs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i]);\n      }\n    }\n    <span class="hljs-keyword">break</span>;\n</code></pre>\n<p><code>targetIndex</code>为触摸点所在小方块序号，<code>cubes</code>为组成魔方的所有小方块，<code>minCubeIndex</code>为所有小方块的最小序号（因为序号并不一定是从 0 开始的，所以需要减去所有小方块中的最小序号），遍历所有小方块并筛选出此次的转动元素，使用<code>boxs</code>数组保存起来。</p>\n<p>在 ThreeJS 框架中创建物体时会自动赋予其<code>id</code>属性且满足递增规律只要创建时按照图中序号递增的规律就可以保证创建的所有小方块的<code>id</code>属性符合上述规律了，但是魔方转动之后小方块位置发生了变化，而且<code>id</code>属性是只读的，不能被修改，因此规律被破坏了；</p>\n<p>对于这种情况我们需要自定义一个属性<code>cubeIndex</code>用来表示编号，在创建小方块时让其等于小方块<code>id</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第148行 */</span>\nitem.<span class="hljs-property">cubeIndex</span> = item.<span class="hljs-property">id</span>;\n</code></pre>\n<p>同时记录下小方块中心点和序号之间的关系，即使转动了魔方也可以通过小方块的中心点和序号的关系，更新所有小方块的序号，让始终保持创建时的规律；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第83行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span> = [];\n\n<span class="hljs-comment">/* Rubik.js 第142行至第148行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>.<span class="hljs-title function_">push</span>({\n    <span class="hljs-attr">x</span>: item.<span class="hljs-property">position</span>.<span class="hljs-property">x</span>,\n    <span class="hljs-attr">y</span>: item.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>,\n    <span class="hljs-attr">z</span>: item.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>,\n    <span class="hljs-attr">cubeIndex</span>: item.<span class="hljs-property">id</span>\n});\n</code></pre>\n<p>小方块中心点和序号之间的关系记录在<code>initStatus</code>数组中。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第424行至第437行 */</span>\n<span class="hljs-title function_">updateCubeIndex</span>(<span class="hljs-params">elements</span>) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) {\n        <span class="hljs-keyword">var</span> temp1 = elements[i];\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>.<span class="hljs-property">length</span>; j++) {\n                <span class="hljs-keyword">var</span> temp2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>[j];\n                <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(temp1.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> - temp2.<span class="hljs-property">x</span>) &lt;= <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span> / <span class="hljs-number">2</span> &amp;&amp;\n                <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(temp1.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> - temp2.<span class="hljs-property">y</span>) &lt;= <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span> / <span class="hljs-number">2</span> &amp;&amp;\n                <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(temp1.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> - temp2.<span class="hljs-property">z</span>) &lt;= <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">len</span> / <span class="hljs-number">2</span>) {\n                temp1.<span class="hljs-property">cubeIndex</span> = temp2.<span class="hljs-property">cubeIndex</span>;\n                <span class="hljs-keyword">break</span>;\n            }\n        }\n    }\n}\n</code></pre>\n<p>更新小方块序号时因为浮点数精度的问题，最好不要用相减等于 0 的比较方式，只要保证中心点坐标距离不超过小方块宽高的一半即可，毕竟一个小方块是不可能存在两个中心点。</p>\n<p>计算转动元素函数完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第287行至第344行 */</span>\n<span class="hljs-title function_">getBoxs</span>(<span class="hljs-params">cubeIndex, direction</span>) {\n    <span class="hljs-keyword">var</span> targetIndex = cubeIndex;\n    targetIndex = targetIndex - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>;\n    <span class="hljs-keyword">var</span> numI = <span class="hljs-built_in">parseInt</span>(targetIndex / <span class="hljs-number">9</span>);\n    <span class="hljs-keyword">var</span> numJ = targetIndex % <span class="hljs-number">9</span>;\n    <span class="hljs-keyword">var</span> boxs = [];\n    <span class="hljs-comment">//根据绘制时的规律判断 no = i*9+j</span>\n    <span class="hljs-keyword">switch</span> (direction) {\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.4</span>:\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n                <span class="hljs-keyword">var</span> tempId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">cubeIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>;\n                <span class="hljs-keyword">if</span> (numI === <span class="hljs-built_in">parseInt</span>(tempId / <span class="hljs-number">9</span>)) {\n                    boxs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i]);\n                }\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.4</span>:\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n                <span class="hljs-keyword">var</span> tempId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">cubeIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>;\n                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(numJ / <span class="hljs-number">3</span>) === <span class="hljs-built_in">parseInt</span>(tempId % <span class="hljs-number">9</span> / <span class="hljs-number">3</span>)) {\n                    boxs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i]);\n                }\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.2</span>:\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n                <span class="hljs-keyword">var</span> tempId = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">cubeIndex</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>;\n                <span class="hljs-keyword">if</span> (tempId % <span class="hljs-number">9</span> % <span class="hljs-number">3</span> === numJ % <span class="hljs-number">3</span>) {\n                    boxs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i]);\n                }\n            }\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-attr">default</span>:\n        <span class="hljs-keyword">break</span>;\n    }\n    <span class="hljs-keyword">return</span> boxs;\n}\n</code></pre>\n<p>很多转动方向其实是等效的，计算转动元素时可以合并在一起。</p>\n<h3 data-id="heading-8">实现转动动画</h3>\n<p>实现转动动画之前需要先定义转动动画相关参数，比如动画时长；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第84行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultTotalTime</span> = <span class="hljs-number">250</span>;<span class="hljs-comment">//默认转动动画时长</span>\n</code></pre>\n<p>为了保证动画不至于过快也不至于过慢，这里动画时长定为<code>250毫秒</code>。</p>\n<p>另外在 Web 开发时一般使用<code>requestAnimationFrame</code>来实现动画，微信小游戏中也提供了类似的对象，可以直接使用。</p>\n<p>动画函数完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第351行至第419行 */</span>\n<span class="hljs-title function_">rotateAnimation</span>(<span class="hljs-params">elements, direction, currentstamp, startstamp, laststamp, callback, totalTime</span>) {\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">var</span> isAnimationEnd = <span class="hljs-literal">false</span>;<span class="hljs-comment">//动画是否结束</span>\n    \n    <span class="hljs-keyword">if</span> (startstamp === <span class="hljs-number">0</span>) {\n        startstamp = currentstamp;\n        laststamp = currentstamp;\n    }\n    <span class="hljs-keyword">if</span> (currentstamp - startstamp &gt;= totalTime) {\n        isAnimationEnd = <span class="hljs-literal">true</span>;\n        currentstamp = startstamp + totalTime;\n    }\n    <span class="hljs-keyword">var</span> rotateMatrix = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Matrix4</span>();<span class="hljs-comment">//旋转矩阵</span>\n    <span class="hljs-keyword">var</span> origin = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> xLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> yLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);\n    <span class="hljs-keyword">var</span> zLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n    \n    <span class="hljs-keyword">switch</span> (direction) {\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.3</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, zLine, -<span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.4</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, zLine, <span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.4</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, yLine, -<span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">1.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">0.3</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.4</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.3</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, yLine, <span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.2</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, xLine, <span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-keyword">case</span> <span class="hljs-number">2.1</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">3.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">4.2</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-number">5.1</span>:\n            rotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, xLine, -<span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n            <span class="hljs-keyword">break</span>;\n        <span class="hljs-attr">default</span>:\n            <span class="hljs-keyword">break</span>;\n    }\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) {\n        elements[i].<span class="hljs-title function_">applyMatrix</span>(rotateMatrix);\n    }\n    <span class="hljs-keyword">if</span> (!isAnimationEnd) {\n        <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">timestamp</span>) {\n            self.<span class="hljs-title function_">rotateAnimation</span>(elements, direction, timestamp, startstamp, currentstamp, callback, totalTime);\n        });\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-title function_">callback</span>();\n    }\n}\n</code></pre>\n<p>基本思路就是在设定的动画时长内旋转 90 度，需要注意的地方在于<code>rotateAroundWorldAxis</code>这个方法；首先旋转时不能直接调用物体的<code>rotateX</code>、<code>rotateY</code>、<code>rotateZ</code>等方法；以绕<code>Y轴</code>逆时针转动为例，如果直接调用就会看到如下效果：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/29/1675eacffa6e6d2f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p><code>rotateX</code>、<code>rotateY</code>、<code>rotateZ</code>这些方法被定义为基于物体自身坐标系而言的，因此你会看到每个小方块都是直接绕着其<code>自身坐标系的Y轴</code>转动的，而实际转动操作需要基于<code>魔方坐标系的Y轴</code>转动；</p>\n<p>为了解决这个问题，我们需要实现一个函数，它可以实现<code>绕着过某一点的向量旋转一定角度</code>；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第470行至第488行 */</span>\n<span class="hljs-title function_">rotateAroundWorldAxis</span>(<span class="hljs-params">p, vector, rad</span>) {\n    vector.<span class="hljs-title function_">normalize</span>();\n    <span class="hljs-keyword">var</span> u = vector.<span class="hljs-property">x</span>;\n    <span class="hljs-keyword">var</span> v = vector.<span class="hljs-property">y</span>;\n    <span class="hljs-keyword">var</span> w = vector.<span class="hljs-property">z</span>;\n    \n    <span class="hljs-keyword">var</span> a = p.<span class="hljs-property">x</span>;\n    <span class="hljs-keyword">var</span> b = p.<span class="hljs-property">y</span>;\n    <span class="hljs-keyword">var</span> c = p.<span class="hljs-property">z</span>;\n    \n    <span class="hljs-keyword">var</span> matrix4 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Matrix4</span>();\n    \n    matrix4.<span class="hljs-title function_">set</span>(u * u + (v * v + w * w) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad), u * v * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) - w * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), u * w * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + v * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), (a * (v * v + w * w) - u * (b * v + c * w)) * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + (b * w - c * v) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad),\n        u * v * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + w * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), v * v + (u * u + w * w) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad), v * w * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) - u * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), (b * (u * u + w * w) - v * (a * u + c * w)) * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + (c * u - a * w) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad),\n        u * w * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) - v * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), v * w * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + u * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad), w * w + (u * u + v * v) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad), (c * (u * u + v * v) - w * (a * u + b * v)) * (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(rad)) + (a * v - b * u) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(rad),\n        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n    \n    <span class="hljs-keyword">return</span> matrix4;\n}\n</code></pre>\n<p><code>rotateAroundWorldAxis</code>就是我们需要的函数（推导过程大家可以去网上查<code>3d 任意点 向量旋转</code>或者类似关键词），它接收<code>点p</code>和向量<code>vector</code>以及旋转弧度<code>rad</code>，返回<code>绕着过点p的向量vector旋转rad弧度的变换矩阵</code>；绕着魔方坐标系Z轴旋转可以理解为<code>绕着过原点(0,0,0)的向量(0,0,1)旋转</code>，其变换矩阵可以由以下代码求出：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第364行 */</span>\n<span class="hljs-keyword">var</span> origin = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n\n<span class="hljs-comment">/* Rubik.js 第367行 */</span>\n<span class="hljs-keyword">var</span> zLine = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n\n<span class="hljs-comment">/* Rubik.js 第374行 */</span>\nrotateMatrix = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateAroundWorldAxis</span>(origin, zLine, -<span class="hljs-number">90</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span> * (currentstamp - laststamp) / totalTime);\n</code></pre>\n<p>已知变换矩阵，就可以遍历转动元素，然后分别乘以变换矩阵即可：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第409行至411行 */</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) {\n    elements[i].<span class="hljs-title function_">applyMatrix</span>(rotateMatrix);\n}\n</code></pre>\n<p>至此转动函数的完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第442行至454行 */</span>\n<span class="hljs-title function_">rotateMove</span>(<span class="hljs-params">cubeIndex, direction, callback, totalTime</span>) {\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    totalTime = totalTime ? totalTime : <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultTotalTime</span>;\n    <span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBoxs</span>(cubeIndex, direction);\n    <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">timestamp</span>) {\n        self.<span class="hljs-title function_">rotateAnimation</span>(elements, direction, timestamp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n            self.<span class="hljs-title function_">updateCubeIndex</span>(elements);\n            <span class="hljs-keyword">if</span> (callback) {\n                <span class="hljs-title function_">callback</span>();\n            }\n        }, totalTime);\n    });\n}\n</code></pre>\n<p>已知触摸小方块序号、转动方向然后求得转动元素，最后执行转动动画即可。</p>\n<h3 data-id="heading-9">完整流程</h3>\n<p>在<code>rotateRubik</code>函数中计算出触摸小方块序号以及转动方向就可以直接调用魔方的<code>rotateMove</code>方法进行转动了；</p>\n<p><code>rotateRubik</code>函数完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第168行至179行 */</span>\n<span class="hljs-title function_">rotateRubik</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> = <span class="hljs-literal">true</span>;<span class="hljs-comment">//转动标识置为true</span>\n    <span class="hljs-keyword">var</span> sub = <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>);<span class="hljs-comment">//计算滑动方向</span>\n    <span class="hljs-keyword">var</span> direction = <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-title function_">getDirection</span>(sub, <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span>);<span class="hljs-comment">//计算转动方向</span>\n    <span class="hljs-keyword">var</span> cubeIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>.<span class="hljs-property">object</span>.<span class="hljs-property">cubeIndex</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-title function_">rotateMove</span>(cubeIndex, direction);\n    <span class="hljs-keyword">var</span> anotherIndex = cubeIndex - <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span>.<span class="hljs-property">minCubeIndex</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span>.<span class="hljs-title function_">rotateMove</span>(anotherIndex, direction, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n        self.<span class="hljs-title function_">resetRotateParams</span>();\n    });\n}\n</code></pre>\n<p>在逻辑上正反视角魔方是同一个魔方，因此正视角魔方的转动方向和触摸小方块序号和反视角魔方的一样，正反视角魔方同时执行其<code>rotateMove</code>方法即可；</p>\n<p>另外转动完成之后还需要对转动参数进行重置，防止对下一次转动造成影响。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第184行至192行 */</span>\n<span class="hljs-title function_">resetRotateParams</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> = <span class="hljs-literal">false</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">normalize</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> = <span class="hljs-literal">null</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span> = <span class="hljs-literal">null</span>;\n}\n</code></pre>\n<p>最终效果如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/29/1675ed312d25c29d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-10">总结</h2>\n<p>在这一章中我们实现了魔方转动功能，让这个简单的魔方小游戏具备了最基础的可玩性，在实现过程中需要注意多坐标系的概念，另外<code>在准备解决某个问题之前最好先仔细分析一下！</code></p></div>',
  },
  {
    name: "7\n视图转动\n学习时长: 9分2秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">视图转动</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>实现魔方视图转动功能；</li>\n<li>魔方整体转动分析及实现。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p><code>视图转动</code>如下图所示：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/16764d8529c0d2d2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>示例代码在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo5" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo5" ref="nofollow noopener noreferrer">Threejs_rubik</a>项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/16764dd5626ed150~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">实现</h2>\n<p>视图转动也就是魔方整体转动和转动魔方某一层其实只有两点区别；</p>\n<ol>\n<li>转动魔方某一层的操作区域在魔方表面而魔方整体转动的操作区域在魔方外部；</li>\n<li>转动魔方某一层只涉及特定一层的小方块而魔方整体转动涉及组成魔方的全部小方块。</li>\n</ol>\n<p>兼容这两个差异之后，魔方整体转动和转动魔方某一层其实是等价的，如图：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5fcd7c6fb977~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在魔方区域外部的屏幕上操作时整个区域可以通过<code>X轴</code>和<code>Y轴</code>以及两条和 X 轴夹角为 30 度的<code>辅助虚线</code>划分为<code>a</code>、<code>b</code>、<code>e</code>、<code>f</code>、<code>g</code>、<code>d</code>六个区域，这六个区域分别对应魔方整体转动的六种类型；</p>\n<p>需要注意的是这六个区域并不是触摸点和滑动点的坐标区域而是触摸点和滑动点组成向量的区域，比如从<code>R点</code>滑动到<code>S点</code>，虽然两个点坐标都在<code>d</code>区域，但是它们组成的向量的区域在<code>a</code>区域，因此这个滑动也属于<code>a</code>区域滑动；</p>\n<p>在<code>a</code>区域，向右滑动，比如<code>OA</code>对应魔方的<code>HJ</code>转动；如果在<code>a</code>区域，向左滑动，比如<code>AO</code>则对应魔方的<code>JH</code>转动，屏幕滑动和魔方整体转动的对应关系如下：</p>\n<ul>\n<li><code>OA</code>:<code>HJ</code>；</li>\n<li><code>OD</code>:<code>HI</code>；</li>\n<li><code>OB</code>:<code>HK</code>；</li>\n<li><code>OF</code>:<code>LN</code>；</li>\n<li><code>OG</code>:<code>LM</code>；</li>\n<li><code>OE</code>:<code>LP</code>；</li>\n</ul>\n<p>对于魔方的<code>HJ</code>、<code>HI</code>、<code>HK</code>、<code>LN</code>、<code>LM</code>、<code>LP</code>的转动在上一章已经处理过了，接下来需要处理的是判断魔方区域外部屏幕上的滑动属于哪种情况，以<code>d</code>区域的<code>OD</code>滑动来说：</p>\n<p>当触摸点处于右半边屏幕且向斜上方滑动，对应代码：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第251行至第254行 */</span>\n<span class="hljs-keyword">var</span> direction;\n<span class="hljs-keyword">var</span> rad = <span class="hljs-number">30</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>;\n<span class="hljs-keyword">var</span> lenX = movePoint.<span class="hljs-property">x</span> - startPoint.<span class="hljs-property">x</span>;\n<span class="hljs-keyword">var</span> lenY = movePoint.<span class="hljs-property">y</span> - startPoint.<span class="hljs-property">y</span>;\n\n<span class="hljs-comment">/* main.js 第256行至第270行 */</span>\n<span class="hljs-keyword">if</span>(startPoint.<span class="hljs-property">x</span>&gt;<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>/<span class="hljs-number">2</span>){\n    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenY) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(rad)){\n        <span class="hljs-keyword">if</span>(lenY&lt;<span class="hljs-number">0</span>){\n            direction = <span class="hljs-number">2.1</span>;\n        }<span class="hljs-keyword">else</span>{\n            direction = <span class="hljs-number">3.1</span>;\n        }\n    }\n}\n</code></pre>\n<p><code>movePoint</code>和<code>startPoint</code>表示滑动点和触摸点，<code>startPoint.x&gt;window.innerWidth/2</code>则表示触摸点处于右半边屏幕，<code>Math.abs(lenY) &gt; Math.abs(lenX) * Math.tan(30/180*Math.PI)</code>意味着滑动点和触摸点组成的向量和 X 轴的夹角大于 30 度，也就是此次滑动要么属于<code>d</code>区域，要么属于<code>b</code>区域；</p>\n<p>最后通过<code>lenY</code>也就是滑动点和触摸点 y 值的差的正负判断是向上还是向下，如果是向下则此次滑动属于<code>b</code>区域对应魔方的<code>HK</code>转动也就是<code>direction=2.1</code>，表示向 Y 轴正方向旋转 90 度，且触摸平面是 Z 轴正平面。</p>\n<p>获得视图转动方向函数完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第250行至第317行 */</span>\n<span class="hljs-title function_">getViewDirection</span>(<span class="hljs-params">type,startPoint,movePoint</span>){\n    <span class="hljs-keyword">var</span> direction;\n    <span class="hljs-keyword">var</span> rad = <span class="hljs-number">30</span>*<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>/<span class="hljs-number">180</span>;\n    <span class="hljs-keyword">var</span> lenX = movePoint.<span class="hljs-property">x</span> - startPoint.<span class="hljs-property">x</span>;\n    <span class="hljs-keyword">var</span> lenY = movePoint.<span class="hljs-property">y</span> - startPoint.<span class="hljs-property">y</span>;\n    <span class="hljs-keyword">if</span>(type==<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span>){\n        <span class="hljs-keyword">if</span>(startPoint.<span class="hljs-property">x</span>&gt;<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>/<span class="hljs-number">2</span>){\n            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenY) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(rad)){\n                <span class="hljs-keyword">if</span>(lenY&lt;<span class="hljs-number">0</span>){\n                    direction = <span class="hljs-number">2.1</span>;\n                }<span class="hljs-keyword">else</span>{\n                    direction = <span class="hljs-number">3.1</span>;\n                }\n            }<span class="hljs-keyword">else</span>{\n                <span class="hljs-keyword">if</span>(lenX&gt;<span class="hljs-number">0</span>){\n                    direction = <span class="hljs-number">0.3</span>;\n                }<span class="hljs-keyword">else</span>{\n                    direction = <span class="hljs-number">1.3</span>;\n                }\n            }\n        }<span class="hljs-keyword">else</span>{\n            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenY) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(rad)) {\n                <span class="hljs-keyword">if</span> (lenY &lt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">2.4</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">3.4</span>;\n                }\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">if</span> (lenX &gt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">4.4</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">5.4</span>;\n                }\n            }\n        }\n    }<span class="hljs-keyword">else</span>{\n        <span class="hljs-keyword">if</span> (startPoint.<span class="hljs-property">x</span> &gt; <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-number">2</span>) {\n            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenY) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(rad)) {\n                <span class="hljs-keyword">if</span> (lenY &lt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">2.2</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">3.2</span>;\n                }\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">if</span> (lenX &gt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">1.4</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">0.4</span>;\n                }\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenY) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lenX) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(rad)) {\n                <span class="hljs-keyword">if</span> (lenY &lt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">2.3</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">3.3</span>;\n                }\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-keyword">if</span> (lenX &gt; <span class="hljs-number">0</span>) {\n                    direction = <span class="hljs-number">5.3</span>;\n                } <span class="hljs-keyword">else</span> {\n                    direction = <span class="hljs-number">4.3</span>;\n                }\n            }\n        }\n    }\n    <span class="hljs-keyword">return</span> direction;\n}\n</code></pre>\n<p>处理完滑动方向的映射关系之后，还需要确定小方块序号，选取正视角魔方或者反视角魔方中水平方向的两个面相交处任意小方块均可；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第239行至第245行 */</span>\n<span class="hljs-title function_">getViewRotateCubeIndex</span>(<span class="hljs-params">type</span>){\n    <span class="hljs-keyword">if</span> (type == <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontViewName</span>){\n        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;\n    }<span class="hljs-keyword">else</span>{\n        <span class="hljs-keyword">return</span> <span class="hljs-number">65</span>;\n    }\n}\n</code></pre>\n<p>当我们把魔方区域外的滑动映射为魔方区域上的滑动，且明确了转动方向和小方块序号，就可以编写魔方整体转动函数了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第459行至第473行 */</span>\n<span class="hljs-title function_">rotateMoveWhole</span>(<span class="hljs-params">cubeIndex, direction, callback, totalTime</span>){\n    <span class="hljs-keyword">if</span>(cubeIndex!=<span class="hljs-literal">null</span>&amp;&amp;direction!=<span class="hljs-literal">null</span>){\n        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n        totalTime = totalTime ? totalTime : <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultTotalTime</span>;\n        <span class="hljs-keyword">var</span> elements = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>;\n        <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">timestamp</span>) {\n            self.<span class="hljs-title function_">rotateAnimation</span>(elements, direction, timestamp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n                self.<span class="hljs-title function_">updateCubeIndex</span>(elements);\n                <span class="hljs-keyword">if</span> (callback) {\n                    <span class="hljs-title function_">callback</span>();\n                }\n            }, totalTime);\n        });\n    }\n}\n</code></pre>\n<p>和转动魔方某一层函数唯一的区别就是转动元素为全部小方块<code>var elements = this.cubes</code>。</p>\n<p>魔方整体转动触摸点和滑动点坐标直接使用屏幕坐标就好了，因此需要在触摸开始事件回调函数<code>touchStart</code>以及触摸移动事件回调函数<code>touchMove</code>中和转动魔方某一层的触摸点以及滑动点坐标区分开：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第125行至第127行 */</span>\n<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>){<span class="hljs-comment">//触摸点没在魔方上</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(touch.<span class="hljs-property">clientX</span>, touch.<span class="hljs-property">clientY</span>);\n}\n\n<span class="hljs-comment">/* main.js 第149行至第154行 */</span>\n<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">intersect</span>){<span class="hljs-comment">//触摸点没在魔方上</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(touch.<span class="hljs-property">clientX</span>, touch.<span class="hljs-property">clientY</span>);\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>.<span class="hljs-title function_">equals</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>)) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateView</span>();\n    }\n}\n</code></pre>\n<p>当触摸点没在魔方上且魔方没有转动时，执行<code>rotateView</code>函数转动魔方整体，调整视图。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第193行至第213行 */</span>\n<span class="hljs-title function_">rotateView</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>.<span class="hljs-property">y</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>.<span class="hljs-property">y</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">touchLine</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>;\n    }\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> = <span class="hljs-literal">true</span>;<span class="hljs-comment">//转动标识置为true</span>\n        <span class="hljs-comment">//计算整体转动方向</span>\n        <span class="hljs-keyword">var</span> targetType = <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">childType</span>;\n        <span class="hljs-keyword">var</span> cubeIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getViewRotateCubeIndex</span>(targetType);\n        <span class="hljs-keyword">var</span> direction = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getViewDirection</span>(targetType, <span class="hljs-variable language_">this</span>.<span class="hljs-property">startPoint</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">movePoint</span>);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetRubik</span>.<span class="hljs-title function_">rotateMoveWhole</span>(cubeIndex, direction);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">anotherRubik</span>.<span class="hljs-title function_">rotateMoveWhole</span>(cubeIndex, direction, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n            self.<span class="hljs-title function_">resetRotateParams</span>();\n        });\n    }\n}\n</code></pre>\n<p>整个流程为先判断目标魔方，然后把屏幕上魔方区域外的滑动映射为魔方上的滑动，兼容处理转动元素为全部小方块，然后执行转动动画即可。</p>\n<h2 data-id="heading-4">总结</h2>\n<p>在不支持视图转动之前，虽说也能看到魔方全部六个面，但是对于我这种空间想象能力不够的人来说，查看两种视图然后相互映射比转一下直接查看要慢很多，因此这里加上了视图转动；实现这个功能只需要想<code>清楚操作类型划分</code>以及<code>合理利用已有功能</code>就可以了。</p></div>',
  },
  {
    name: "8\n初始动画\n学习时长: 24分11秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">初始动画</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>实现魔方小游戏初始动画功能；</li>\n<li>Tween.js 补间动画库的用法；</li>\n<li>魔方随机转动分析及实现。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p>到目前为止你进入这个魔方小游戏看到的应该是如下画面：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/1/16769373ce3280d4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>假设你作为一个用户以前没怎么接触魔方，看到这个应该是比较困惑的，进来了然后干嘛呢？</p>\n<p>因此进入小游戏后应该有一个打乱的过程而且最好能以动画的形式展现出来，比如：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676f5b24f4c63ab~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo6" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo6" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/3/168141a74e9f5c8d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<h2 data-id="heading-3">实现</h2>\n<p>初始动画由两部分组成；一部分是打乱动画，另一部分是位置动画；</p>\n<h3 data-id="heading-4">打乱动画</h3>\n<p>打乱动画其实就是随机转动魔方，在<code>转动魔方</code>那一章实现过转动魔方函数<code>rotateMove</code>，那打乱也就是随机执行转动魔方函数；</p>\n<p><code>rotateMove</code>函数有四个参数：</p>\n<ul>\n<li><code>cubeIndex</code>表示触摸小方块序号；</li>\n<li><code>direction</code>表示转动方向；</li>\n<li><code>callback</code>表示转动魔方回调函数；</li>\n<li><code>totalTime</code>表示转动动画时长；</li>\n</ul>\n<p>随机执行转动魔方函数也就是随机选取触摸小方块序号和转动方向；但是要注意一点，魔方转动方向共有六种，但是小方块不同面的转动方向有且只有四种，而且不完全相同；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5d4a50ea67e7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>如图<code>A点</code>的转动方向只有<code>AB</code>、<code>AC</code>、<code>AE</code>、<code>AD</code>四种；而<code>F点</code>的转动方向也只有四种分别为<code>FJ </code>、<code>FG</code>、<code>FI</code>、<code>FH</code>，它们之间并不是完全相同的；</p>\n<p>初一看起来随机选取这些元素还有略微有点复杂，有没有更简单的方式呢？</p>\n<p>答案是有的！</p>\n<p>在前人总结的魔方还原公式中，把魔方转动的情况抽象为<code>12种</code>基本转动，如图：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676e0da8a05d56f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image">\n<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676f2bef7686480~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>以<code>U</code>魔方上层绕 Y 轴作顺时针旋转 90 度为例：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/25/167e5d66d3f7266e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>触摸小方块序号为<code>0</code>，转动方向可由<code>getDirection</code>函数得到为<code>1.3</code>，代码实现如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第527行至第529行 */</span>\n<span class="hljs-title function_">U</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">1.3</span>, next, <span class="hljs-number">100</span>);\n}\n</code></pre>\n<p>根据相同的方法可得其它转动的代码实现如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第530行至第562行 */</span>\n<span class="hljs-title function_">R</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">2.4</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">F</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">4.1</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">D</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">6</span>, <span class="hljs-number">4.4</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">L</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">18</span>, <span class="hljs-number">1.1</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">B</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">2</span>, <span class="hljs-number">2.1</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">u</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">4.4</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">r</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">1.1</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">f</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span>, <span class="hljs-number">2.1</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">d</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">6</span>, <span class="hljs-number">1.3</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">l</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">18</span>, <span class="hljs-number">2.4</span>, next, <span class="hljs-number">100</span>);\n}\n<span class="hljs-title function_">b</span>(<span class="hljs-params">next</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotateMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minCubeIndex</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4.1</span>, next, <span class="hljs-number">100</span>);\n}\n</code></pre>\n<p>打乱动画要稍快于正常转动动画，因此动画时长设为<code>100</code>毫秒。</p>\n<p>实现这 12 种基本转动之后，随机转动打乱魔方的问题就转换成从 12 种基本转动中随机选取转动函数序列然后按顺序依次执行的问题了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第588行至第598行 */</span>\n<span class="hljs-title function_">randomRotate</span>(<span class="hljs-params">callback</span>) {\n    <span class="hljs-keyword">var</span> stepNum = <span class="hljs-number">21</span>;\n    <span class="hljs-keyword">var</span> stepArr = [];\n    <span class="hljs-keyword">var</span> funcArr = [<span class="hljs-string">\'R\'</span>, <span class="hljs-string">\'U\'</span>, <span class="hljs-string">\'F\'</span>, <span class="hljs-string">\'B\'</span>, <span class="hljs-string">\'L\'</span>, <span class="hljs-string">\'D\'</span>, <span class="hljs-string">\'r\'</span>, <span class="hljs-string">\'u\'</span>, <span class="hljs-string">\'f\'</span>, <span class="hljs-string">\'b\'</span>, <span class="hljs-string">\'l\'</span>, <span class="hljs-string">\'d\'</span>];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stepNum; i++) {\n        <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * funcArr.<span class="hljs-property">length</span>);\n        stepArr.<span class="hljs-title function_">push</span>(funcArr[num]);\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">runMethodAtNo</span>(stepArr, <span class="hljs-number">0</span>, callback);\n    <span class="hljs-keyword">return</span> stepArr;\n}\n</code></pre>\n<p>随机转动首先要解决获取随机转动序列的问题；</p>\n<p><code>stepNum</code>为序列长度，定义为<code>21</code>是因为目前最少步数还原算法大概需要 20 多步；因此<code>21步</code>能<code>很大概率</code>保证打乱之后是一个比较复杂的情况，另外奇数也能一定程度确保随机转动之后不会还是起始状态；</p>\n<p><code>funcArr</code>是 12 种基本转动函数名称数组，我们要做的就是从这个数组中随机选取一个元素，放入到随机序列中；</p>\n<p>然后把得到的随机序列传入<code>runMethodAtNo</code>函数中让其按顺序执行；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第567行至第583行 */</span>\n<span class="hljs-title function_">runMethodAtNo</span>(<span class="hljs-params">arr, no, next</span>) {\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">if</span> (no &gt;= arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {\n        <span class="hljs-keyword">if</span> (next) {\n            <span class="hljs-variable language_">this</span>[arr[no]](next);\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-variable language_">this</span>[arr[no]]();\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-variable language_">this</span>[arr[no]](<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n            <span class="hljs-keyword">if</span> (no &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {\n                no++\n                self.<span class="hljs-title function_">runMethodAtNo</span>(arr, no, next);\n            }\n        })\n    }\n}\n</code></pre>\n<p>在<code>runMethodAtNo</code>函数中我们使用递归的方法实现按顺序执行传入的随机序列中的基本转动函数；<code>no</code>表示待执行转动函数在序列中的序号，如果是最后一项直接执行即可，如果不是则需要在执行的时候指定回调方法，在回调方法中序号递增且再次执行<code>runMethodAtNo</code>函数。</p>\n<h3 data-id="heading-5">位置动画</h3>\n<p>在打乱的过程中魔方需要从一个位置移动到另一个位置，在移动过程中还伴随着一定的转动；</p>\n<p>在具体实现之前我们需要引入<code>Tween.js</code>，这是一个用 JavaScript 实现的补间动画库，它能帮助开发者计算出两个状态之间的中间状态，获得了中间状态，开发者只需要在屏幕每次重绘时不断更新物体的状态即可。</p>\n<p>首先需要去 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftweenjs%2Ftween.js" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tweenjs/tween.js" ref="nofollow noopener noreferrer">tween.js的github仓库</a> 下载源代码；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676f315c6db4d62~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>然后在项目中新增目录以及代码文件；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676f302ee0a7319~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>接着在<code>main.js</code>文件中引入；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第2行 */</span>\n<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">TWEEN</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'tween/tween.js\'</span>\n</code></pre>\n<p>准备工作完成之后就可以开始实现位置动画了；</p>\n<p>首先定义一个变量用来标识动画结束；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第325行 */</span>\n<span class="hljs-keyword">var</span> isAnimationEnd = <span class="hljs-literal">false</span>;\n</code></pre>\n<p>然后定义动画开始前的状态和动画结束后的状态；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第327行至第331行 */</span>\n<span class="hljs-keyword">var</span> endStatus = {<span class="hljs-comment">//目标状态</span>\n    <span class="hljs-attr">rotateY</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span>,\n    <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>,\n    <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>\n}\n</code></pre>\n<p>动画结束后的状态也就是正视角魔方创建完成之后的状态，在位置动画中有变化的属性只有三个：</p>\n<ul>\n<li><code>rotateY</code>表示绕 Y 轴旋转的角度；</li>\n<li><code>y</code>表示正视角魔方中心 Y 轴坐标；</li>\n<li><code>z</code>表示正视角魔方中心 Z 轴坐标；</li>\n</ul>\n<p>接着把正视角魔方变换到动画开始前的状态；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第333行至第335行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">rotateY</span>(-<span class="hljs-number">90</span> / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<span class="hljs-comment">//把魔方设置为动画开始状态</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">originHeight</span>/<span class="hljs-number">3</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> -= <span class="hljs-number">350</span>;\n</code></pre>\n<p>绕 Y 轴顺时针旋转 90 度且中心向上同时向内移动一定的距离，向上移动的距离不能为固定值否则有可能在其它尺寸的屏幕出现越界的情况；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第337行至第341行 */</span>\n<span class="hljs-keyword">var</span> startStatus = {<span class="hljs-comment">//开始状态</span>\n    <span class="hljs-attr">rotateY</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span>,\n    <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>,\n    <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>\n}\n</code></pre>\n<p>把正视角魔方变换到动画开始前的状态之后就可以记录其此时的状态了。</p>\n<p>Tween 的使用方法很简单；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第343行至第352行 */</span>\n<span class="hljs-keyword">var</span> tween = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title class_">Tween</span>(startStatus)\n                .<span class="hljs-title function_">to</span>(endStatus, <span class="hljs-number">2000</span>)\n                .<span class="hljs-title function_">easing</span>(<span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-property">Easing</span>.<span class="hljs-property">Quadratic</span>.<span class="hljs-property">In</span>)\n                .<span class="hljs-title function_">onUpdate</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n                    self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = startStatus.<span class="hljs-property">rotateY</span>;\n                    self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = startStatus.<span class="hljs-property">y</span>\n                    self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = startStatus.<span class="hljs-property">z</span>\n                }).<span class="hljs-title function_">onComplete</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n                    isAnimationEnd = <span class="hljs-literal">true</span>;\n                });\n</code></pre>\n<p>熟悉 JQuery 的童鞋应该对这种链式写法很熟悉；</p>\n<p>在创建时指定开始状态，然后在<code>to</code>方法中指定结束状态以及补间动画时长，而<code>easing</code>方法可以用来指定运动函数和 CSS 的 transition-timing-function 属性类似；</p>\n<p>另外还需要设置<code>onUpdate</code>和<code>onComplete</code>回调函数，每次状态的更新都会触发<code>onUpdate</code>监听，在回调函数中实时更新魔方状态即可；结束时会触发<code>onComplete</code>监听，此时需要改变改变标识变量。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第354行至第359行 */</span>\n<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">time</span>) {\n    <span class="hljs-keyword">if</span> (!isAnimationEnd){\n        <span class="hljs-title function_">requestAnimationFrame</span>(animate);\n        <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title function_">update</span>();\n    }\n}\n    \n<span class="hljs-comment">/* main.js 第361行至第364行 */</span>\n<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n    tween.<span class="hljs-title function_">start</span>();\n    <span class="hljs-title function_">requestAnimationFrame</span>(animate);\n},<span class="hljs-number">500</span>)\n</code></pre>\n<p>补间动画创建并设置完成之后还需要执行<code>start</code>函数才能开始，而且在<code>requestAnimationFrame</code>函数中还需要执行<code>TWEEN.update</code>；</p>\n<p><code>500毫秒延迟</code>是为了让位置动画比打乱动画慢开始。</p>\n<h3 data-id="heading-6">调用</h3>\n<p>至此完整的初始动画如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第323行至第370行 */</span>\n<span class="hljs-title function_">enterAnimation</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">var</span> isAnimationEnd = <span class="hljs-literal">false</span>;\n\n    <span class="hljs-keyword">var</span> endStatus = {<span class="hljs-comment">//目标状态</span>\n        <span class="hljs-attr">rotateY</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span>,\n        <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>,\n        <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>\n    }\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-title function_">rotateY</span>(-<span class="hljs-number">90</span> / <span class="hljs-number">180</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<span class="hljs-comment">//把魔方设置为动画开始状态</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">originHeight</span>/<span class="hljs-number">3</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> -= <span class="hljs-number">350</span>;\n\n    <span class="hljs-keyword">var</span> startStatus = {<span class="hljs-comment">//开始状态</span>\n        <span class="hljs-attr">rotateY</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span>,\n        <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>,\n        <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span>\n    }\n\n    <span class="hljs-keyword">var</span> tween = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title class_">Tween</span>(startStatus)\n                    .<span class="hljs-title function_">to</span>(endStatus, <span class="hljs-number">2000</span>)\n                    .<span class="hljs-title function_">easing</span>(<span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-property">Easing</span>.<span class="hljs-property">Quadratic</span>.<span class="hljs-property">In</span>)\n                    .<span class="hljs-title function_">onUpdate</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n                        self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = startStatus.<span class="hljs-property">rotateY</span>;\n                        self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = startStatus.<span class="hljs-property">y</span>\n                        self.<span class="hljs-property">frontRubik</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = startStatus.<span class="hljs-property">z</span>\n                    }).<span class="hljs-title function_">onComplete</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n                        isAnimationEnd = <span class="hljs-literal">true</span>;\n                    });\n\n    <span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">time</span>) {\n        <span class="hljs-keyword">if</span> (!isAnimationEnd){\n            <span class="hljs-title function_">requestAnimationFrame</span>(animate);\n            <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title function_">update</span>();\n        }\n    }\n\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n        tween.<span class="hljs-title function_">start</span>();\n        <span class="hljs-title function_">requestAnimationFrame</span>(animate);\n    },<span class="hljs-number">500</span>)\n    \n    <span class="hljs-keyword">var</span> stepArr = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">randomRotate</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">runMethodAtNo</span>(stepArr, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n        self.<span class="hljs-title function_">initEvent</span>();<span class="hljs-comment">//进场动画结束之后才能进行手动操作</span>\n    });\n}\n</code></pre>\n<p>在<code>initObject</code>函数中创建完 UI 以及魔方元素后就可以运行动画了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第101行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">enterAnimation</span>();\n</code></pre>\n<p>最后要注意的一个地方在于为了保证初始动画不被其它操作所干扰，需要把事件初始化函数<code>initEvent</code>在游戏主逻辑对象的构建函数中执行改为在初始动画结束回调中执行。</p>\n<h2 data-id="heading-7">总结</h2>\n<p>复杂的问题可以拆分成多个简单的子问题处理，动画的实现也是如此；另外 12 种基本转动函数的实现并不是唯一的主要取决坐标系的选取。</p></div>',
  },
  {
    name: "9\n辅助功能\n学习时长: 14分48秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">辅助功能</h1>\n<h2 data-id="heading-1">前言</h2>\n<p>在这一章中你将学到以下知识点：</p>\n<ol>\n<li>实现魔方小游戏各项辅助功能；</li>\n<li>魔方状态的矩阵表示；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象<code>matrix</code>属性含义及应用；</li>\n<li>ThreeJS 框架中<code>Object3D</code>对象<code>matrix</code>属性和<code>matrixWorld</code>属性的差异；</li>\n<li>ThreeJS 框架中<code>Scene</code>对象删除元素；</li>\n<li>ThreeJS 框架中<code>CanvasTexture</code>对象和<code>Texture</code>对象的联系及区别。</li>\n</ol>\n<h2 data-id="heading-2">概述</h2>\n<p>可以说目前我们已经完成这个魔方小游戏的主要功能，还剩下一些辅助功能，比如<code>重置</code>、<code>打乱</code>、<code>存档</code>、<code>读取</code>等功能；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/5/1677d2d926f320fe~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>示例代码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo7" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo7" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/5/1677d8cc71d0f898~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>之所以会加这些辅助功能是因为有些魔方还原算法是一步步达成目标的，比如初学者常用的<code>层先法</code>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/3/167734faa00bbaeb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>在学习过程中很难一蹴而就，其中的每一步从了解到熟练都需要重复很多次，因此基于这种一开始不能完整还原但是又需要重复训练的情况，加入了这些辅助功能。</p>\n<h2 data-id="heading-3">实现</h2>\n<p>在<code>正反视图</code>那章我们处理过控制条 UI 元素，在这里可以采用同样的方法处理<code>重置按钮</code>、<code>打乱按钮</code>、<code>存档按钮</code>、<code>读取按钮</code>；</p>\n<h3 data-id="heading-4">1. 绘制 UI 元素</h3>\n<p>以重置按钮举例来说：</p>\n<p>重置按钮素材图片如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/3/167735ac432a075b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>把图片素材统一存放到<code>images</code>目录中，并在<code>object</code>目录中新增<code>ResetBtn.js</code>；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/3/1677375763b8411a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'../threejs/three.js\'</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetBtn</span> {\n\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">main</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span> = main;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">false</span>;\n    \n        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-comment">//实际尺寸</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> = <span class="hljs-number">64</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> = <span class="hljs-number">64</span>;\n    \n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">750</span>;\n    \n        <span class="hljs-comment">//逻辑尺寸</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>;\n    \n        <span class="hljs-comment">//屏幕尺寸</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span> = {\n            <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>,\n            <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>\n        }\n    \n        <span class="hljs-comment">//加载图片</span>\n        <span class="hljs-keyword">var</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();\n        loader.<span class="hljs-title function_">load</span>(<span class="hljs-string">\'images/reset-btn.png\'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">texture</span>) {\n            <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(self.<span class="hljs-property">width</span>, self.<span class="hljs-property">height</span>);\n            <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n            self.<span class="hljs-property">plane</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\n            self.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n            self.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(self.<span class="hljs-property">plane</span>)\n            self.<span class="hljs-title function_">defaultPosition</span>();\n        }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((xhr.<span class="hljs-property">loaded</span> / xhr.<span class="hljs-property">total</span> * <span class="hljs-number">100</span>) + <span class="hljs-string">\'% loaded\'</span>);\n        }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'An error happened\'</span>);\n        });\n    }\n}\n</code></pre>\n<p><code>实际尺寸</code>可以由图片素材宽度决定；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* ResetBtn.js 第11行至第12行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> = <span class="hljs-number">64</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> = <span class="hljs-number">64</span>;\n</code></pre>\n<p><code>逻辑尺寸</code>等于<code>实际尺寸</code>乘以缩放比率；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* ResetBtn.js 第17行至第18行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>;\n</code></pre>\n<p><code>缩放比率</code>则等于 UI 元素所在平面宽度除以设计稿页面宽度；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* ResetBtn.js 第14行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">750</span>;\n</code></pre>\n<p>重置按钮的屏幕尺寸计算和控制条不一样，控制条可以明确的知道投影到屏幕上时应该是完全铺满屏幕的，那么就可以确定控制条屏幕尺寸的宽度，然后根据宽高等比缩放的原则可以求出控制条屏幕尺寸的高度；</p>\n<p>但是重置按钮并不能确定投影到屏幕上的宽高，此时可以根据控制条的屏幕尺寸计算投影缩放比率；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第114行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiRadio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;\n</code></pre>\n<p>然后保证所有 UI 元素都遵循同一缩放比率即可。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第21行至第24行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span> = {\n    <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>,\n    <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>\n}\n</code></pre>\n<p>最后根据图片路径加载图片，在加载成功回调函数中创建重置按钮并加入到场景中即可，在<code>defaultPosition</code>函数中定义默认位置。</p>\n<blockquote>\n<p>其它 UI 元素也类似，就不一一赘述了。</p>\n</blockquote>\n<p>各种 UI 元素定义完成之后在需要在<code>main.js</code>中引入；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ResetBtn</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/ResetBtn.js\'</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">DisorganizeBtn</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/DisorganizeBtn.js\'</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">SaveBtn</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/SaveBtn.js\'</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">RestoreBtn</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'object/RestoreBtn.js\'</span>\n</code></pre>\n<p>然后在<code>initObject</code>函数中统一创建即可。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">//重置按钮</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">resetBtn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResetBtn</span>(<span class="hljs-variable language_">this</span>);\n<span class="hljs-comment">//混乱按钮</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">disorganizeBtn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisorganizeBtn</span>(<span class="hljs-variable language_">this</span>);\n<span class="hljs-comment">//保存按钮</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaveBtn</span>(<span class="hljs-variable language_">this</span>);\n<span class="hljs-comment">//还原按钮</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">restoreBtn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestoreBtn</span>(<span class="hljs-variable language_">this</span>);\n</code></pre>\n<h3 data-id="heading-5">2. 重置魔方</h3>\n<p>由于经过一系列打乱动画、转动魔方、转动视图、调整正反视图区域大小操作后，魔方的位置和开始的时候已经有了很大差别；</p>\n<p>而重置魔方操作只需要把魔方还原成每个面颜色一致的状态，并不需要把正反视图区域大小也还原为初始状态；</p>\n<p>这就要求有些变换需要还原，比如打乱动画、转动魔方、转动视图；而有些变换不需要还原，比如调整正反视图区域大小；</p>\n<p>在前边的实现过程中我们既没有记录做了哪些变换操作，又没有对这些变换操作进行区分，粗一看起来实现重置魔方功能略微有些复杂，要想简单处理貌似只有重新创建场景这个方法。</p>\n<p>实际上基于 ThreeJS 框架提供的一些功能使得重置魔方位置比你想象的要简单；在<code>魔方转动</code>那一章曾提到过<code>Object3D</code>对象有一个<code>matrixWorld</code>属性保存了物体在世界坐标系变换矩阵，这个对象还有一个<code>matrix</code>属性保存了物体在其父元素坐标系中的变换矩阵（如果物体没有父元素那么<code>matrix</code>和<code>matrixWorld</code>相同）；</p>\n<p>魔方小方块的父元素是<code>Group</code>对象，只需要对这些方块做<code>matrix</code>的逆矩阵的变换就可以让魔方小方块回到其相对于父元素的初始位置了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第615行至第618行 */</span>\n<span class="hljs-keyword">var</span> matrix = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">matrix</span>.<span class="hljs-title function_">clone</span>();\nmatrix.<span class="hljs-title function_">getInverse</span>(matrix);\n<span class="hljs-keyword">var</span> cube = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i];\ncube.<span class="hljs-title function_">applyMatrix</span>(matrix);\n</code></pre>\n<p><code>matrix.clone()</code>会克隆当前矩阵创建一个新的矩阵，<code>matrix.getInverse(matrix)</code>会得到<code>matrix</code>的逆反矩阵，之后执行<code>cube.applyMatrix(matrix)</code>对小方块做逆反矩阵变换即可，效果如下：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/4/167781c3b4f7c415~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>你可能会问，27 个小方块变成 1 个这是还原操作吗？</p>\n<p>主要是因为创建这 27 个小方块时默认其中心都在父元素自身坐标系的坐标原点，那么对所有小方块做逆反矩阵变换自然都会回到初始位置，看起来也就重叠在一起了；</p>\n<p>从图中可以看到转动魔方和转动视图操作都被还原了，但是调整正反视图区域大小的操作并没有，刚好符合要求。</p>\n<p>只需要把所有小方块中心重新设置为初始中心位置就可以解决重叠在一起的问题了，而小方块的初始中心位置以及对应<code>id</code>在魔方创建时就已经保存在<code>initStatus</code>数组中了；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第620行至第629行 */</span>\n<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>.<span class="hljs-property">length</span>;j++){\n    <span class="hljs-keyword">var</span> status = <span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>[j];\n    <span class="hljs-keyword">if</span> (cube.<span class="hljs-property">id</span> == status.<span class="hljs-property">cubeIndex</span>){\n        cube.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = status.<span class="hljs-property">x</span>;\n        cube.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = status.<span class="hljs-property">y</span>;\n        cube.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = status.<span class="hljs-property">z</span>;\n        cube.<span class="hljs-property">cubeIndex</span> = cube.<span class="hljs-property">id</span>;\n        <span class="hljs-keyword">continue</span>;\n    }\n}\n</code></pre>\n<p>遍历数组然后根据<code>id</code>属性还原即可。</p>\n<p>完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第613行至第631行 */</span>\n<span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>;i++){\n        <span class="hljs-keyword">var</span> matrix = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">matrix</span>.<span class="hljs-title function_">clone</span>();\n        matrix.<span class="hljs-title function_">getInverse</span>(matrix);\n        <span class="hljs-keyword">var</span> cube = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i];\n        cube.<span class="hljs-title function_">applyMatrix</span>(matrix);\n    \n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>.<span class="hljs-property">length</span>;j++){\n            <span class="hljs-keyword">var</span> status = <span class="hljs-variable language_">this</span>.<span class="hljs-property">initStatus</span>[j];\n            <span class="hljs-keyword">if</span> (cube.<span class="hljs-property">id</span> == status.<span class="hljs-property">cubeIndex</span>){\n                cube.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = status.<span class="hljs-property">x</span>;\n                cube.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = status.<span class="hljs-property">y</span>;\n                cube.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = status.<span class="hljs-property">z</span>;\n                cube.<span class="hljs-property">cubeIndex</span> = cube.<span class="hljs-property">id</span>;\n                <span class="hljs-keyword">break</span>;\n            }\n        }\n    }\n}\n</code></pre>\n<h3 data-id="heading-6">3. 打乱魔方</h3>\n<p>有重置功能自然需要对应的打乱功能，在<code>初始动画</code>那一章我们已经分析过怎么随机打乱一个魔方了，这里只需要把打乱魔方逻辑从初始动画函数<code>enterAnimation</code>中封装抽离出来即可。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第303行至第305行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disorganizeRubik</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n    self.<span class="hljs-title function_">initEvent</span>();<span class="hljs-comment">//进场动画结束之后才能进行手动操作</span>\n})\n\n<span class="hljs-comment">/* main.js 第505行至第517行 */</span>\n<span class="hljs-title function_">disorganizeRubik</span>(<span class="hljs-params">callback</span>){\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span> = <span class="hljs-literal">true</span>;\n        <span class="hljs-keyword">var</span> stepArr = <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">randomRotate</span>();\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">runMethodAtNo</span>(stepArr, <span class="hljs-number">0</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n            <span class="hljs-keyword">if</span> (callback){\n                <span class="hljs-title function_">callback</span>();\n            }\n            self.<span class="hljs-title function_">resetRotateParams</span>();\n        });\n    }\n}\n</code></pre>\n<h3 data-id="heading-7">4. 存储魔方</h3>\n<p>重置和打乱功能只能保证不管能不能还原魔方都能回到魔方的初始状态，而存档和读取则能保证可以随时回到特定状态。</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/5/1677d55711456dc4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>点击存档之后，按钮下方会出现一个不断旋转的小魔方，因此存储魔方可以采用克隆一个新魔方的方法，并把克隆得到的新魔方定位到特定位置。</p>\n<p>在重置魔方功能的实现中我们已经知道所谓的魔方状态其实是由小方块位置决定的，而小方块的位置则是由其变换矩阵<code>matrix</code>决定的，也就是说魔方的状态其实就存储在小方块的变换矩阵中；</p>\n<p>那么克隆魔方也就是复制该魔方小方块的变换矩阵了。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* Rubik.js 第636行至第655行 */</span>\n<span class="hljs-title function_">save</span>(<span class="hljs-params">rubik, position ,number</span>) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>.<span class="hljs-property">length</span>; i++) {\n        <span class="hljs-keyword">var</span> matrix = rubik.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">matrix</span>.<span class="hljs-title function_">clone</span>();\n        <span class="hljs-keyword">var</span> selfMat = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-property">matrix</span>.<span class="hljs-title function_">clone</span>();\n        selfMat = selfMat.<span class="hljs-title function_">getInverse</span>(selfMat);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-title function_">applyMatrix</span>(selfMat);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>[i].<span class="hljs-title function_">applyMatrix</span>(matrix);\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateCubeIndex</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cubes</span>);\n    \n    <span class="hljs-keyword">if</span> (position){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = position.<span class="hljs-property">x</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = position.<span class="hljs-property">y</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = position.<span class="hljs-property">z</span>;\n    }\n    \n    <span class="hljs-keyword">if</span> (number!=<span class="hljs-literal">null</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span>.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(number, number, number);\n    }\n}\n</code></pre>\n<p>存储魔方函数<code>saveRubik</code>接收三个参数，分别是：</p>\n<ul>\n<li><code>rubik</code>表示克隆的样例魔方；</li>\n<li><code>position</code>表示新魔方的中心点；</li>\n<li><code>number</code>表示缩放倍数；</li>\n</ul>\n<p>遍历魔方中的小方块然后使其变换到克隆的样例魔方中小方块的位置，然后更新小方块索引；如果传入新的中心点和缩放倍数则需要设置中心以及进行缩放。</p>\n<p>存储魔方状态函数<code>saveRubik</code>完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第522行至第558行 */</span>\n<span class="hljs-title function_">saveRubik</span>(<span class="hljs-params"></span>){\n    wx.<span class="hljs-title function_">showLoading</span>({\n        <span class="hljs-attr">title</span>: <span class="hljs-string">\'存档中...\'</span>,\n        <span class="hljs-attr">mask</span>:<span class="hljs-literal">true</span>\n    })\n    \n    <span class="hljs-keyword">var</span> bgCanvas = <span class="hljs-title function_">background</span>();\n    <span class="hljs-keyword">var</span> radio = <span class="hljs-variable language_">this</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">750</span>;\n    \n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicRubik</span>(<span class="hljs-variable language_">this</span>);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-title function_">model</span>();\n    }\n    <span class="hljs-keyword">var</span> tagPosition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">getPosition</span>();\n    tagPosition.<span class="hljs-property">y</span> -= <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>+<span class="hljs-number">15</span>;\n    tagPosition.<span class="hljs-property">x</span> += (<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-property">width</span> - bgCanvas.<span class="hljs-property">width</span>) / <span class="hljs-number">2</span> * radio;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-title function_">save</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>, tagPosition, <span class="hljs-number">0.05</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-property">group</span>);\n    \n    <span class="hljs-comment">//添加灰色半透明背景</span>\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>){\n        <span class="hljs-keyword">var</span> bgWidth = bgCanvas.<span class="hljs-property">width</span> * radio;\n        <span class="hljs-keyword">var</span> bgHeight = bgCanvas.<span class="hljs-property">height</span> * radio;\n        <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(bgWidth, bgHeight);\n        <span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CanvasTexture</span>(bgCanvas);\n        <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = tagPosition.<span class="hljs-property">x</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = tagPosition.<span class="hljs-property">y</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = tagPosition.<span class="hljs-property">z</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>);\n    \n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n        wx.<span class="hljs-title function_">hideLoading</span>()\n    },<span class="hljs-number">500</span>)\n}\n</code></pre>\n<p>在这个函数中需要几点需要注意的地方：</p>\n<ul>\n<li>\n<p><code>wx.showLoading</code>和<code>wx.hideLoading</code>是为了防止过多且过快的点击存储按钮；</p>\n</li>\n<li>\n<p>如果<code>标签魔方</code>和<code>圆角矩形半透明背景</code>已经存在了则不需要再次创建，只需要更新其状态就好了；</p>\n</li>\n<li>\n<p><code>var bgCanvas = background()</code>是生成圆角矩形半透明背景；</p>\n</li>\n<li>\n<p>在绘制<code>圆角矩形半透明背景</code>时使用了<code>CanvasTexture</code>对象，它其实继承自<code>Texture</code>对象；区别在于<code>CanvasTexture</code>对象只能使用<code>Canvas</code>元素作为素材且其<code>needsUpdate</code>属性默认为<code>true</code>，这样才能保证<code>Canvas</code>元素内容被完全加载了；</p>\n</li>\n<li>\n<p><code>标签魔方</code>的中心位置可以由<code>存储按钮</code>的位置计算得到。</p>\n</li>\n</ul>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> tagPosition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">getPosition</span>();\ntagPosition.<span class="hljs-property">y</span> -= <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>+<span class="hljs-number">15</span>;\ntagPosition.<span class="hljs-property">x</span> += (<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-property">width</span> - bgCanvas.<span class="hljs-property">width</span>) / <span class="hljs-number">2</span> * radio;\n</code></pre>\n<h3 data-id="heading-8">5. 读取魔方</h3>\n<p>读取魔方只需要让正视角魔方和反视角魔方都复制<code>标签魔方</code>就好了，另外还需要从场景中删除调<code>标签魔方</code>以及<code>背景</code>。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第563行至第575行 */</span>\n<span class="hljs-title function_">restoreRubik</span>(<span class="hljs-params"></span>){\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>){\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>.<span class="hljs-title function_">save</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">endRubik</span>.<span class="hljs-title function_">save</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>);\n    \n        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>) {\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-property">group</span>);\n        }\n        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>) {\n            <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>);\n        }\n    }\n}\n</code></pre>\n<h3 data-id="heading-9">6. 事件处理</h3>\n<p>点击<code>重置</code>、<code>打乱</code>、<code>存储</code>、<code>读取</code>等按钮都需要在触摸开始事件的回调函数<code>touchStart</code>中处理；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第196行至第208行 */</span>\n<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">resetBtn</span>.<span class="hljs-title function_">isHover</span>(touch) &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resetBtn</span>.<span class="hljs-title function_">enable</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resetRubik</span>();\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">disorganizeBtn</span>.<span class="hljs-title function_">isHover</span>(touch) &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disorganizeBtn</span>.<span class="hljs-title function_">enable</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disorganizeRubik</span>();\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">isHover</span>(touch) &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">enable</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveRubik</span>();\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">restoreBtn</span>.<span class="hljs-title function_">isHover</span>(touch) &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRotating</span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">restoreBtn</span>.<span class="hljs-title function_">enable</span>();\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">restoreRubik</span>();\n}\n</code></pre>\n<p>最后在触摸结束事件的回调函数<code>touchEnd</code>中重置它们的状态。</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* main.js 第251行至第254行 */</span>\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">resetBtn</span>.<span class="hljs-title function_">disable</span>();\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">disorganizeBtn</span>.<span class="hljs-title function_">disable</span>();\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">disable</span>();\n<span class="hljs-variable language_">this</span>.<span class="hljs-property">restoreBtn</span>.<span class="hljs-title function_">disable</span>();\n</code></pre>\n<h2 data-id="heading-10">总结</h2>\n<p>了解 ThreeJS 框架的各种对象的用法能帮助你熟悉这个框架，但是如果你想掌握这个框架估计得从掌握<code>Object3D</code>这个对象开始！</p></div>',
  },
  {
    name: "10\n代码整理\n学习时长: 13分24秒",
    content:
      '<div class="markdown-body"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h1 data-id="heading-0">代码整理</h1>\n<h2 data-id="heading-1">概述</h2>\n<p>本来只凑了九小节，但是有小伙伴反馈代码写的很烂，而且自己在扩展<code>变阶</code>功能的时候感觉确实如此。</p>\n<h2 data-id="heading-2">整理</h2>\n<p>自我审视了一下代码，感觉主要问题在以下几点：</p>\n<h3 data-id="heading-3">1、逻辑冗余</h3>\n<p>简易三阶魔方的 27 个小方块是一样的，每个小方块存在六个面，那么只需要六个 Canvas 素材生成六种不同颜色的材质即可；</p>\n<p>但是在实际代码中每创建一个方块就创建了六个 Canvas 素材生成了六种不同颜色的材质；</p>\n<p>问题代码截图如下（注意红框中的部分）：</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/3/1680f82b91751986~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>优化后<code>Rubik.js</code>中的<code>SimpleCube</code>方法如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SimpleCube</span>(<span class="hljs-params">x, y, z, num, len, colors</span>) {\n    <span class="hljs-comment">//魔方左上角坐标</span>\n    <span class="hljs-keyword">var</span> leftUpX = x - num / <span class="hljs-number">2</span> * len;\n    <span class="hljs-keyword">var</span> leftUpY = y + num / <span class="hljs-number">2</span> * len;\n    <span class="hljs-keyword">var</span> leftUpZ = z + num / <span class="hljs-number">2</span> * len;\n    \n    <span class="hljs-comment">//根据颜色生成材质</span>\n    <span class="hljs-keyword">var</span> materialArr = [];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>.<span class="hljs-property">length</span>; i++) {\n        <span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(<span class="hljs-title function_">faces</span>(<span class="hljs-title class_">BasicParams</span>.<span class="hljs-property">colors</span>[i]));\n        texture.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>;\n        <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>({ <span class="hljs-attr">map</span>: texture });\n        materialArr.<span class="hljs-title function_">push</span>(material);\n    }\n    \n    <span class="hljs-keyword">var</span> cubes = [];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) {\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; num * num; j++) {\n            <span class="hljs-keyword">var</span> cubegeo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(len, len, len);\n            <span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(cubegeo, materialArr);\n            \n            <span class="hljs-comment">//依次计算各个小方块中心点坐标</span>\n            cube.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = (leftUpX + len / <span class="hljs-number">2</span>) + (j % num) * len;\n            cube.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = (leftUpY - len / <span class="hljs-number">2</span>) - <span class="hljs-built_in">parseInt</span>(j / num) * len;\n            cube.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = (leftUpZ - len / <span class="hljs-number">2</span>) - i * len;\n            cubes.<span class="hljs-title function_">push</span>(cube);\n        }\n    }\n    <span class="hljs-keyword">return</span> cubes;\n}\n</code></pre>\n<p>优化点在于在创建小方块之前就根据颜色创建 Canvas 素材并生成好需要的材质保存起来，后续只是对这六种材质的复用。</p>\n<h3 data-id="heading-4">2、逻辑重复</h3>\n<p>代码中的各个按钮对象除了素材图片及其尺寸、空间位置不一样以外，其它都大同小异，但是我们并没有对这些相似逻辑进行封装；</p>\n<p>其实可以把重复逻辑抽象出来，封装成<code>UIComponent</code>对象，用来处理小游戏中的自定义UI组件；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'../threejs/three.js\'</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UIComponentt</span> {\n\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}\n    \n    <span class="hljs-comment">/**\n     * 加载纹理背景\n     */</span>\n    <span class="hljs-title function_">loadBackground</span>(<span class="hljs-params"></span>){}\n    \n    <span class="hljs-comment">/**\n     * 在场景中显示和隐藏\n     */</span>\n    <span class="hljs-title function_">showInScene</span>(<span class="hljs-params"></span>){}\n    <span class="hljs-title function_">hideInScene</span>(<span class="hljs-params"></span>){}\n    \n    <span class="hljs-comment">/**\n     * 设置尺寸\n     */</span>\n    <span class="hljs-title function_">setSize</span>(<span class="hljs-params"></span>){}\n    \n    <span class="hljs-comment">/**\n     * 设置位置\n     */</span>\n    <span class="hljs-title function_">setPosition</span>(<span class="hljs-params"></span>) {}\n    \n    <span class="hljs-comment">/**\n     * 获取位置\n     */</span>\n    <span class="hljs-title function_">getPosition</span>(<span class="hljs-params"></span>) {}\n    \n    <span class="hljs-comment">/**\n     * 判断是否在范围内\n     */</span>\n    <span class="hljs-title function_">isHover</span>(<span class="hljs-params"></span>) {}\n    \n    <span class="hljs-comment">/**\n     * 状态切换\n     */</span>\n    <span class="hljs-title function_">enable</span>(<span class="hljs-params"></span>) {}\n    <span class="hljs-title function_">disable</span>(<span class="hljs-params"></span>) {}\n}\n</code></pre>\n<p><code>构造</code>函数接受主游戏逻辑对象中的一些和 UI 相关的参数；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">main</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span> = main;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">false</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">750</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiRadio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>;\n}\n</code></pre>\n<p><code>设置尺寸</code>函数接受实际尺寸，然后根据 UI 缩放比率等参数，推算出逻辑尺寸和屏幕尺寸；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">setSize</span>(<span class="hljs-params">width,height</span>){\n    <span class="hljs-comment">//实际尺寸</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> = width;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> = height;\n    \n    <span class="hljs-comment">//逻辑尺寸</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n    \n    <span class="hljs-comment">//屏幕尺寸</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span> = {\n        <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>,\n        <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>\n    }\n}\n</code></pre>\n<p><code>获取位置</code>函数会返回 UI 元素对象的中心点在空间中的坐标；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">getPosition</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">clone</span>();\n}\n</code></pre>\n<p><code>激活状态切换</code>函数会切换状态属性<code>isActive</code>的值；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">enable</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">true</span>;\n}\n<span class="hljs-title function_">disable</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> = <span class="hljs-literal">false</span>;\n}\n</code></pre>\n<p><code>设置位置</code>函数接受 UI 元素在 3D 空间坐标系中的坐标值，然后更新其在 3D 空间以及投影到屏幕的位置；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">setPosition</span>(<span class="hljs-params">x,y,z</span>) {\n    <span class="hljs-keyword">if</span> (x) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = x;\n    }\n    <span class="hljs-keyword">if</span> (y) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = y;\n    }\n    <span class="hljs-keyword">if</span> (z) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = z;\n    }\n\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">2</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> / <span class="hljs-number">2</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>;\n}\n</code></pre>\n<p><code>判断是否在 UI 元素范围内</code>函数接受触摸点屏幕坐标，然后根据 UI 元素的屏幕位置以及屏幕尺寸判断；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">isHover</span>(<span class="hljs-params">touch</span>) {\n    <span class="hljs-keyword">var</span> isHover = <span class="hljs-literal">false</span>;\n    <span class="hljs-keyword">if</span> (touch.<span class="hljs-property">clientY</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> &amp;&amp; touch.<span class="hljs-property">clientY</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">height</span> &amp;&amp; touch.<span class="hljs-property">clientX</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> &amp;&amp; touch.<span class="hljs-property">clientX</span> &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">width</span>) {\n      isHover = <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">return</span> isHover;\n}\n</code></pre>\n<p><code>显示状态切换</code>函数会把 UI 对象加入到场景中或者将其从场景中删除；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">showInScene</span>(<span class="hljs-params"></span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>);\n}\n<span class="hljs-title function_">hideInScene</span>(<span class="hljs-params"></span>){\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>);\n}\n</code></pre>\n<p><code>加载纹理背景</code>函数接受图片素材的 url 路径以及回调方法，使用纹理加载器加载图片素材，然后创建平面对象用于绘制 UI 元素；当加载完成且绘制成功之后再执行回调函数；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">loadBackground</span>(<span class="hljs-params">url, callback</span>){\n    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n    <span class="hljs-keyword">var</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();\n    loader.<span class="hljs-title function_">load</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">texture</span>) {\n        <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(self.<span class="hljs-property">width</span>, self.<span class="hljs-property">height</span>);\n        <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n        self.<span class="hljs-property">plane</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\n        self.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);\n        self.<span class="hljs-title function_">showInScene</span>();\n        <span class="hljs-keyword">if</span> (callback) {\n            <span class="hljs-title function_">callback</span>();\n        }\n    }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((xhr.<span class="hljs-property">loaded</span> / xhr.<span class="hljs-property">total</span> * <span class="hljs-number">100</span>) + <span class="hljs-string">\'% loaded\'</span>);\n    }, <span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) {\n        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\'An error happened\'</span>);\n    });\n}\n</code></pre>\n<p>有了<code>UIComponent</code>对象，我们再创建 UI 元素时，就只需要在其构造函数中设置尺寸以及加载图片素材即可；以还原按钮<code>ResetBtn</code>对象为例，代码可以优化如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'../threejs/three.js\'</span>\n<span class="hljs-keyword">import</span> <span class="hljs-title class_">UIComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\'./UIComponent.js\'</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetBtn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">UIComponent</span> {\n\n    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">main</span>) {\n        <span class="hljs-variable language_">super</span>(main);\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setSize</span>(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>);\n    \n        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadBackground</span>(<span class="hljs-string">\'images/reset-btn.jpg\'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {\n            self.<span class="hljs-title function_">defaultPosition</span>();\n        });\n    }\n\n    <span class="hljs-comment">/**\n     * 默认位置\n     */</span>\n    <span class="hljs-title function_">defaultPosition</span>(<span class="hljs-params"></span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = -<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">2</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-number">2</span> + <span class="hljs-number">45</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> / <span class="hljs-number">2</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> * <span class="hljs-number">3</span> / <span class="hljs-number">2</span> - <span class="hljs-number">35</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">radio</span>;\n        \n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">left</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originWidth</span> / <span class="hljs-number">2</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>;\n        <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenRect</span>.<span class="hljs-property">top</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">originHeight</span> / <span class="hljs-number">2</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span>.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">main</span>.<span class="hljs-property">uiRadio</span>;\n    }\n}\n</code></pre>\n<h3 data-id="heading-5">3、逻辑混乱</h3>\n<p>没有整理代码之前在游戏主逻辑文件<code>main.js</code>中存在两个方法，分别是创建圆角矩形的<code>radiusRect</code>方法和生成半透明背景的<code>background</code>，这两个和 UI 相关的方法出现在游戏主逻辑文件中很明显有点混乱了；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/3/16813eb9f73728b7~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>我们需要把它们封装到<code>UIComponnet</code>对象中才算合理，而且状态魔方的灰色半透明圆角矩形背景本身就算是 UI 相关元素；</p>\n<p>之前<code>UIComponnet</code>对象只支持加载图片素材生成 UI 元素，这里新增一个<code>loadStyle</code>方法，让其可以根据简单的<code>类 CSS 样式</code>规则生成 UI 元素；</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">loadStyle</span>(<span class="hljs-params">uiParams</span>) {\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span> = uiParams;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span> : <span class="hljs-number">1</span>;<span class="hljs-comment">//设备像素比默认为1</span>\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">height</span>);\n    <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>);\n    <span class="hljs-keyword">var</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CanvasTexture</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_background</span>());\n    <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({ <span class="hljs-attr">map</span>: texture, <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span> });\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">plane</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showInScene</span>();\n}\n</code></pre>\n<p><code>uiParams</code>目前支持以下属性：</p>\n<ul>\n<li>宽度<code>width</code>；</li>\n<li>高度<code>height</code>；</li>\n<li>圆角<code>radius</code>；</li>\n<li>背景颜色<code>backgroundColor</code>；</li>\n<li>边框<code>borderTop</code>、<code>borderRight</code>、<code>borderBottom</code>、<code>borderLeft</code>、<code>borderColor</code>；</li>\n<li>文字<code>fontSize</code>、<code>fontColor</code>、<code>fontFamily</code>、<code>fontWeight</code>、<code>content</code>；</li>\n<li>设备像素比<code>pixelRatio</code>（主要用于处理 Canvas 文字模糊问题）。</li>\n</ul>\n<p><code>loadStyle</code>和<code>loadBackground</code>的主要区域在于前者在<code>_background</code>方法中根据类 CSS 样式规则生成 Canvas 素材充当 UI 元素的背景，后者直接加载图片素材充当 UI 元素的背景；</p>\n<p><code>_background</code>方法具体实现如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">_background</span>(<span class="hljs-params"></span>) {\n    <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">\'canvas\'</span>);\n    canvas.<span class="hljs-property">width</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realWidth</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>;\n    canvas.<span class="hljs-property">height</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">realHeight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_radiusRect</span>(canvas, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">radius</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, canvas.<span class="hljs-property">width</span>, canvas.<span class="hljs-property">height</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">backgroundColor</span>);\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">radius</span>) {<span class="hljs-comment">//暂时不支持圆角边框</span>\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_border</span>(canvas, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">borderTop</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">borderRight</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">borderBottom</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">borderLeft</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">borderColor</span>)\n    }\n    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">content</span>) {\n        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_text</span>(canvas, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">fontSize</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">pixelRatio</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">fontFamily</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">fontColor</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">content</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiParams</span>.<span class="hljs-property">fontWeight</span>);\n    }\n    <span class="hljs-keyword">return</span> canvas;\n}\n</code></pre>\n<p><code>UIComponent</code>对象中的<code>_background</code>方法也就是未优化之前在<code>main.js</code>中的<code>background</code>方法了；在此方法中先创建 Canvas 元素然后依次执行<code>_radiusRect</code>、<code>_border</code>、<code>_text</code>等方法处理对应的类 CSS 样式规则；</p>\n<p>而<code>_radiusRect</code>方法则是未优化之前在<code>main.js</code>中的<code>radiusRect</code>方法；</p>\n<p>这些方法中都是些 Canvas API 的使用，比如使用 textAlign 属性可以实现 Canvas 绘制文字水平居中；使用 textBaseline 属性可以实现 Canvas 绘制文字垂直居中等。</p>\n<p>扩展<code>UIComponent</code>对象的能力之后，就可以把<code>main.js</code>中的存储魔方<code>saveRubik</code>方法中生成状态魔方半透明背景的代码封装成直接使用<code>UIComponent</code>对象实现；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/3/16813f8b5029ecb0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>图片中红色部分为未优化代码，绿色部分为优化后的代码；</p>\n<p>优化后<code>main.js</code>的<code>saveRubik</code>方法完整代码如下：</p>\n<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">saveRubik</span>(<span class="hljs-params"></span>){\n    wx.<span class="hljs-title function_">showLoading</span>({\n      <span class="hljs-attr">title</span>: <span class="hljs-string">\'存档中...\'</span>,\n      <span class="hljs-attr">mask</span>:<span class="hljs-literal">true</span>\n    })\n\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicRubik</span>(<span class="hljs-variable language_">this</span>);\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-title function_">model</span>();\n    }\n    <span class="hljs-keyword">var</span> tagPosition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-title function_">getPosition</span>();\n    tagPosition.<span class="hljs-property">y</span> -= <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveBtn</span>.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> + <span class="hljs-number">15</span>;\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-title function_">save</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">frontRubik</span>, tagPosition, <span class="hljs-number">0.05</span>);\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubik</span>.<span class="hljs-property">group</span>);\n\n    <span class="hljs-comment">//添加灰色半透明背景</span>\n    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>) {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UIComponent</span>(<span class="hljs-variable language_">this</span>);\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-title function_">loadStyle</span>({\n        <span class="hljs-attr">width</span>: <span class="hljs-number">64</span>,\n        <span class="hljs-attr">height</span>: <span class="hljs-number">64</span>,\n        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">\'rgba(0,0,0,0.1)\'</span>,\n        <span class="hljs-attr">radius</span>: <span class="hljs-number">8</span>\n      });\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-title function_">showInScene</span>();\n    }\n    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagRubikBg</span>.<span class="hljs-title function_">setPosition</span>(tagPosition.<span class="hljs-property">x</span>, tagPosition.<span class="hljs-property">y</span>, tagPosition.<span class="hljs-property">z</span>);\n\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){\n      wx.<span class="hljs-title function_">hideLoading</span>()\n    },<span class="hljs-number">500</span>)\n}\n</code></pre>\n<h3 data-id="heading-6">4、逻辑晦涩</h3>\n<p>另外在<code>魔方转动分析</code>那里的逻辑有点晦涩，转动方向使用了<code>1.1</code>、<code>2.3</code>这种不太容易理解的数字常量区分方法；不过对于这个问题目前我并没有想到太好的优化方案，大家可以思考一下。</p>\n<h2 data-id="heading-7">总结</h2>\n<p>整理之后的完整代码在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FnewbieYoung%2FThreejs_rubik%2Ftree%2Fmaster%2Flesson%2Fdemo8" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo8" ref="nofollow noopener noreferrer">Threejs_rubik</a> 项目中；</p>\n<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/3/16814156f4ab9dbb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>\n<p>因为水平有限，代码中或大或小的问题，肯定不仅仅只有上边那些，大家可以自由发挥，随意吐槽。</p></div>',
  },
];

const fetch = require("node-fetch");
const stream = require("stream");
async function getImgReplace(content) {
  const match = content.match(/https:\/\/\S{10,}awebp/g) || [];

  for await (let img of match) {
    let imgPath = img.replace("https:/", "").replace(/\//g, "").replace(/:/g, '');
    content = content.replace(img, imgPath);
    const response = await fetch(img);
    stream.pipeline(response.body, fs.createWriteStream(imgPath), (err) => {
      console.log(err);
    });
  }
  return content;
}

totalData.map(async (i) => {
  const index = i.name.split("\n")[0];
  const name = i.name.split("\n")[1];
  const content = await getImgReplace(i.content);
  fs.writeFileSync(
    `./${index}${name}.html`,

    `<!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title></title>
    </head>
    <body>
    ${content}
    </body>
    </html>`
  );
});